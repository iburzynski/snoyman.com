<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Deploying Haskell Services</title>
        <link rel="stylesheet" href="/static/reveal/css/reveal.css">
        <link rel="stylesheet" href="/static/reveal/css/theme/black.css" id="theme">
        <link rel="stylesheet" href="/static/reveal/css/highlight/zenburn.css">
        <link rel="stylesheet" href="/static/reveal/css/print/paper.css" type="text/css" media="print">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown data-separator="^\r?\n---\r?\n$" data-separator-vertical="^\r?\n----\r?\n$">
                  

# Deploying Haskell Services

* Michael Snoyman
* VP Engineering, FP Complete&lt;br&gt;&lt;img alt=&quot;FP Complete logo&quot; src=&quot;https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;images&#x2F;fp-complete-logo-small.png&quot; style=&quot;border:0&quot;&gt;
* Amsterdam Haskell meetup
* Thursday, September 19, 2019

---

## Haskell network services

* Use lots of Haskell
* Mostly network services
* Build&#x2F;deploy&#x2F;monitor
* First question... why Haskell?

---

## Why Haskell (in general)?

* Reliable code
* Highly productive
* Easy to scale to a large team
* Avoid large classes of bugs

---

## Why Haskell (network services)?

* Green threads
* Efficient runtime&#x2F;servers like Warp
* Immutability, purity, and STM
* Low memory footprint
* Low CPU overhead
* Compiled executable

---

## Simplified Haskell deployment

* Compile executable locally
* Spin up VPS
* `scp` executable to VPS
* `ssh` in, run `screen`, run executable
* Done!

---

## Problems

* System libraries, `libc` and `gmp` version mismatch
* Associated assets
* Unreliable testing story
* Downtime during deployment
* Non-resilient to machine failure
* Non-resilient to cloud provider failure

---

## Solving these problems

* Lots of approaches
* Not a Haskell-specific problem
* At FP Complete: we use general purpose solutions
* Docker, Kubernetes, AWS
* Let&#x27;s step through standard deployment
* Conserve the novelty budget!

---

## CI

* We like Gitlab CI
* Keep the configuration in the repo
* Build with a Docker image too
* `stack.yaml` guarantees identical build plan
* Just last week: rebuilt a web app with a minor tweak still using GHC 7.8
* Artifact: a Docker image for runtime

---

## Testing

* Types are great, but you still need to test!
* Especially integration&#x2F;system tests
* Test the exact Docker image you&#x27;re about to deploy to production

---

## Staging

* Separate CI and production Kubernetes cluster
* Gitlab review apps
* Able to deploy branches to staging cluster and see difference
* Great for interacting with product owners and customers

---

## Production

* Use Kubernetes `deployment` system
* Tests each pod
* Zero downtime for deployment
* Concern: share mutable resources like databases
    * Moral of the story: mutability always sucks

---

## High availability

* Multi-node
* Multi-AZ
* Load balancer
* Auto-scaling group

---

## Configuration

* YAML config files (`Data.Yaml.Config`)
    * Allows environment variable overrides
* Secret credentials (e.g. database passwords) use Kube secrets
    * Currently moving over to Vault
* Can run different configurations in staging and prod

---

## Logging

* Apps dump to `stdout`&#x2F;`stderr`
* We use `rio` and its logging capabilities
* Sometimes use structured logging (with or without `rio`)
* Control log level with environment variables
* Use standard log aggregation tools

---

## Monitoring

* Prometheus
* Monitor standard node and cluster level stats by default
    * Memory, CPU, etc
* Monitor ingress and egress (network traffic, status codes)
* Some apps: add custom monitoring info as desired

---

## Summary

* Very little is Haskell specific
* Use common DevOps tools, providers, services
* Easy to integrate with existing infrastructure
* Haskell + DevOps = reliable services

---

## Questions

* Thanks everyone!


                </section>
            </div>
        </div>

        <script src="/static/reveal/lib/js/head.min.js"></script>
        <script src="/static/reveal/js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: '/static/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: '/static/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: '/static/reveal/plugin/zoom-js/zoom.js', async: true },
              { src: '/static/reveal/plugin/notes/notes.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"center":false,"controls":false};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);
        </script>
    </body>
</html>
