<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Exceptions, transformers, primitive</title>
        <link rel="stylesheet" href="/static/reveal/css/reveal.css">
        <link rel="stylesheet" href="/static/reveal/css/theme/black.css" id="theme">
        <link rel="stylesheet" href="/static/reveal/css/highlight/zenburn.css">
        <link rel="stylesheet" href="/static/reveal/css/print/paper.css" type="text/css" media="print">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown data-separator="^\r?\n---\r?\n$" data-separator-vertical="^\r?\n----\r?\n$">
                  

# Exceptions, transformers, primitive

---

## Error handling

Let&#x27;s discuss the different ways you can handle errors in general

----

## Explicit return checking

Examples: C, Go

```
if err != nil { return err }
```

Explicit, obvious, tedious, easy to forget

----

## Explicit with sum types

Examples: none?

```haskell
eres1 &lt;- doSomething
case eres1 of
  Left e -&gt; handleError1 e
  Right x -&gt; do
    eres2 &lt;- doSomething2 x
    ...
```

* Forced to consider `Left` case...
* Unless you don&#x27;t care about the result (`putStrLn`)

----

## Sum types with language help

Examples: Rust

```rust
let x = doSomething()?;
let y = doSomething2(x);
```

* Bonus: compiler warning&#x2F;error on ignored `Result`
* Less tedious, difficult to get wrong
* Have to wrangle different exception types

----

## Monad transformer

Examples: Haskell, others?

```haskell
foo :: ExceptT MyExceptionType IO Y
foo = do
  x &lt;- doSomething
  y &lt;- doSomething2 x
  return y
```

* Explicit in the exception type
* ... assuming no exceptions in `IO` itself
* Still need to wrangle different exception types

----

## Unchecked runtime exceptions

Examples: almost everyone

```haskell
foo :: IO Y
foo = do
  x &lt;- doSomething
  y &lt;- doSomething2 x
  return y
```

* No idea what can go wrong
* No tedium
* Much faster than transformers
* In Haskell, this means `SomeException` is thrown from `IO`, always

----

## Reality in Haskell

* `IO` _does_ have unchecked exceptions
* `ExceptT` over `IO` has `SomeException`
* My argument: `ExceptT` over `IO`, in practice, is a bad idea
* Question: if we designed Haskell from the ground up today, would we
  still include unchecked exceptions?

---

## Nice things in Haskell

This code is nice

```haskell
timeout tenSeconds someHTTPRequest
```

So is this

```haskell
race fileWatcher userCode
```

How do we get this?

----

## Async exceptions

* Send exceptions to a thread from somewhere else
* No way to control what type of exception may be received
* Therefore: any `IO` action can receive an exception of any type
* Necessitates an unchecked exception world
* Once you have that, you have to assume `IO` can fail with anything
  at any time
    * Caveat: you can `mask` temporarily for resource cleanup purposes

----

## Dealing with async exceptions

&lt;https:&#x2F;&#x2F;haskell-lang.org&#x2F;library&#x2F;safe-exceptions&gt;

Same approach used by the new unliftio package, docs still in transition

---

## What about transformers?

* Already know `ExceptT` can address async exceptions
* Can we deal with synchronous exceptions in transformer code?
* https:&#x2F;&#x2F;www.snoyman.com&#x2F;reveal&#x2F;monad-transformer-state
* https:&#x2F;&#x2F;www.yesodweb.com&#x2F;blog&#x2F;2014&#x2F;05&#x2F;exceptions-cont-monads

---

## Exception handling best practices

* https:&#x2F;&#x2F;www.fpcomplete.com&#x2F;blog&#x2F;2016&#x2F;11&#x2F;exceptions-best-practices-haskell

---

## The RIO monad

&lt;https:&#x2F;&#x2F;www.fpcomplete.com&#x2F;blog&#x2F;2017&#x2F;07&#x2F;the-rio-monad&gt;

---

## Still have time for more?

Let&#x27;s play with some really fun stuff

* https:&#x2F;&#x2F;haskell-lang.org&#x2F;tutorial&#x2F;primitive-haskell
* &lt;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Evaluation_order_and_state_tokens&gt;


                </section>
            </div>
        </div>

        <script src="/static/reveal/lib/js/head.min.js"></script>
        <script src="/static/reveal/js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: '/static/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: '/static/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: '/static/reveal/plugin/zoom-js/zoom.js', async: true },
              { src: '/static/reveal/plugin/notes/notes.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"center":false,"controls":false};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);
        </script>
    </body>
</html>
