<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Haskell from the Inside Out</title>
        <link rel="stylesheet" href="/static/reveal/css/reveal.css">
        <link rel="stylesheet" href="/static/reveal/css/theme/black.css" id="theme">
        <link rel="stylesheet" href="/static/reveal/css/highlight/zenburn.css">
        <link rel="stylesheet" href="/static/reveal/css/print/paper.css" type="text/css" media="print">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown data-separator="^\r?\n---\r?\n$" data-separator-vertical="^\r?\n----\r?\n$">
                  

## Haskell from the Inside Out

* Michael Snoyman
* VP of Engineering, FP Complete
* FLIP, Tel Aviv, Israel
* July 23, 2018

&lt;div style=&quot;text-align:center&quot;&gt;
&lt;div&gt;&lt;img src=&quot;&#x2F;static&#x2F;fpcomplete-logo.png&quot; style=&quot;border:0;margin:0&quot;&gt;&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;

---

## Get the code!

* This is a workshop, right?
* Get the code and tools!
* `git clone https:&#x2F;&#x2F;github.com&#x2F;snoyberg&#x2F;haskell-inside-out`
* Follow instructions in README.md
* Kick it off now, may take some time to download

----

## Format

* This is _not_ a lecture or talk
* This is an interactive workshop
* I&#x27;m going to ask questions
* There will be exercises to play with
* תרגישו בבית

----

## Haskell is _weird_

* Computers are inherently imperative
* Most programming languages are imperative
* Haskell is stubbornly _not_ imperative
* Functional, pure, lazy, immutable...
* Goal today:
    * Understand where this weirdness comes from
    * See why this weirdness is really useful

----

## Purely functional

* Haskell is a purely functional programming language
* Most other weird things derive from that
* Purely functional is nice
    * Better testing
    * &quot;Reason about code&quot;
    * Allows some optimizations
    * Trivially create Software Transactional Memory
* Not obvious how to make this work in a programming language

----

## Diving in

* Start with just one constraint: functions are pure
* We&#x27;ll define that a bit better as we go
* Let&#x27;s see how this affects our ability to write normal code

---

## Pure math

We want to evaluate this arithmetic expression

```
(2 + 3) * (4 + 5)
```

1. Do it in your heads, try to note how you procssed it
2. Let&#x27;s write up an answer in imperative pseudocode

----

## Imperative solution

```
x = 2 + 3;
y = 4 + 5;
z = x * y;
return z;
```

* Any objections?
* Not terribly different from how the processor itself would do things

----

## Variation 1

Do these two things do the same thing?

```
x = 2 + 3;
y = 4 + 5;
z = x * y;
return z;
```

```
y = 4 + 5;
x = 2 + 3;
z = x * y;
return z;
```

----

## Variation 2

Do these two things do the same thing?

```
x = 2 + 3;
y = 4 + 5;
z = x * y;
return z;
```

```
z = x * y;
x = 2 + 3;
y = 4 + 5;
return z;
```

----

## Variation 3

Do these two things do the same thing?

```
x = 2 + 3;
y = 4 + 5;
z = x * y;
return z;
```

```
x1 = 2 + 3;
x2 = 2 + 3;
x3 = 2 + 3;
x4 = 2 + 3;
y = 4 + 5;
z = x4 * y;
return z;
```

----

## Variation 4

Do these two things do the same thing?

```
x = 2 + 3;
y = 4 + 5;
z = x * y;
return z;
```

```
w = 1 + 2;
x = 2 + 3;
y = 4 + 5;
z = x * y;
return z;
```

----

## Takeaways

* Some programs do different things internally, but externaly behave the same
* Must calculate `x` and `y` before `z`
* Can calculate other, irrelevant things like `w`
* Can recalculate `x` as many times as desired

Let&#x27;s do something similar...

---

## Say hi

* Get a name from the user
* Print the name back out
* We&#x27;ll use imperative pseudocode again

----

## Basic solution

```
print(&quot;What&#x27;s your name?&quot;);
str = getString();
print(str);
```

----

## Variation 1

Do these two things do the same thing?

```
print(&quot;What&#x27;s your name?&quot;);
str = getString();
print(str);
```

```
str = getString();
print(&quot;What&#x27;s your name?&quot;);
print(str);
```

----

## Variation 2

Do these two things do the same thing?

```
print(&quot;What&#x27;s your name?&quot;);
str = getString();
print(str);
```

```
print(str);
print(&quot;What&#x27;s your name?&quot;);
str = getString();
```

----

## Variation 3

Do these two things do the same thing?

```
print(&quot;What&#x27;s your name?&quot;);
str = getString();
print(str);
```

```
print(&quot;What&#x27;s your name?&quot;);
str1 = getString();
str2 = getString();
str3 = getString();
str4 = getString();
print(str4);
```

----

## Variation 4

Do these two things do the same thing?

```
print(&quot;What&#x27;s your name?&quot;);
str = getString();
print(str);
```

```
print(&quot;What&#x27;s up?&quot;);
print(&quot;What&#x27;s your name?&quot;);
str = getString();
print(str);
```

----

## Takeaways

* Must call `getString()` and set `str` before running `print(str)`
* Cannot run other, irrelevant things like `print(&quot;Whats&#x27; up?&quot;)`
* Cannot run `getString()` multiple times

Compare to our previous takeaways:

* Must calculate `x` and `y` before `z`
* Can calculate other, irrelevant things like `w`
* Can recalculate `x` as many times as desired

What gives?

---

## Discussion

* What&#x27;s the difference between arithmetic and input&#x2F;output
* What&#x27;s the result of running `2 + 3`?
* What&#x27;s the result of running `getString()`?
* What&#x27;s the result of running `print(&quot;What&#x27;s your name?&quot;)`?

----

## What&#x27;s a function?

* Maps input to output
* What are the input and output to the following:
    * Plus function `+`
    * `getString`
    * `print`
    * `rollDie`

----

## Results of evaluating

* Only result from evaluating `2 + 3`: the number 5
* Two results from evaluating `getString()`
    * Some I&#x2F;O (a prompt to the user)
    * A string value
* Who cares if we have the number 5 multiple times? We ignore the
  unneeded ones!
* But we can&#x27;t ignore the extra I&#x2F;O from `getString`

----

## Back to order of evaluation

* Does it matter if we evaluate `2 + 3 = 5` before `4 + 5 = 9`?
    * __No!__
* Does it matter if we print `What&#x27;s your name` before prompting for a
  name?
    * __Yes!__
* Same rules seem to apply to repeated evaluation and reordered
  evaluation

----

## Focus on math

`(2 + 3) * (4 + 5)`

* Evaluate each subexpression as many times as desired
* Rearrange order of evaluation for subexpressions as desired
* _Must_ evaluate subexpressions before full expression
* Time for some terminology
    * Pure function
    * Data dependency

----

## Pure function

* A function in the mathematical sense
* Deterministic output for given input
* Cannot observe that the function has been run besides having a
  result
    * E.g., no I&#x2F;O
    * Little bit of a lie: we know the CPU got hotter :)
* Different from what we call &quot;functions&quot; in most programming languages!

----

## Data dependency

* Impossible to figure out `x * 2` without knowing `x`
* We have a _data dependency_ on `x`
* Challenge: evaluate `(3 + 4) * 2`, but don&#x27;t figure out `3 + 4`

---

## Can we program purely functionally?

* We already saw that this fell apart for `print` and `getString`
* Why? They aren&#x27;t purely functional!
* Extra result with no data dependency to force order of evaluation
* But pure functions sound so cool!

----

## The state of the world

* `print` affects the state of the world (changes the console)
* `getString` is affected by the state of the world (user input)
* Can we somehow represent that concept in a &quot;purely functional&quot; way?
* Can we create some data dependency out of this?

----

## Fake it

Imagine this crazy rewrite:

```
fn main(iostate1):
  iostate2 = print(&quot;What&#x27;s your name?&quot;, iostate1)
  (iostate3, str) = getString(iostate2)
  iostate4 = print(str, iostate3)
  return iostate4
```

* Cannot try to put `getString` before first print, because...
* We created a data dependency!
* Various `iostate` values force an order of evaluation

---

## Exercise 1

* Go into the exercises directory
* Run `stack build`
* Run `stack runghc ex1-fake-it.hs`
* Make it run :)

```haskell
getString :: IOState -&gt; (IOState, String)
print     :: String -&gt; IOState -&gt; IOState
```

* `getString` takes one argument, returns two values
* `print` takes two arguments, returns one value
* Underscore == &quot;fill in the blank&quot;

----

## How was that?

* It works, but it&#x27;s ugly
* We&#x27;re making our life really difficult
* Can we do better? Yes
* Let&#x27;s make a _pattern_

----

## Type aliases

Haskell lets us create type aliases with variables

```haskell
getString :: IOState -&gt; (IOState, String)
print     :: String -&gt; IOState -&gt; IOState
```

Include &quot;dummy&quot; value in `print`:

```haskell
getString :: IOState -&gt; (IOState, String)
print     :: String -&gt; IOState -&gt; (IOState, ())
```

And now:

```haskell
type Action a = IOState -&gt; (IOState, a)
getString :: Action String
print     :: String -&gt; Action ()
```

A bit easier to see what&#x27;s happening

---

## Exercise 2

* Convert our previous example to the new `Action` type alias
* Use `stack runghc ex2-fake-it-action.hs`

----

## Functions!

* Let&#x27;s do some code reuse

```haskell
promptString :: String -&gt; Action String
promptString msg io1 =
  let (io2, ()) = print msg io1
      (io3, str) = getString io2
   in (io3, str)
```

Which brings us to...

---

## Exercise 3

* Let&#x27;s build some helper functions
* You&#x27;ll need:

```haskell
showInt :: Int -&gt; String
readInt :: String -&gt; Int -- why is this crazy?
```

Make `ex3-prompt-int.hs` work

----

## Problem

* Lots of ceremony to just convert a `String` to an `Int`
* Can we generalize? Of course!

---

## Exercise 4

* Fix the implementation of `mapAction` in `ex4-map-action.hs`

```haskell
mapAction :: (a -&gt; b) -&gt; Action a -&gt; Action b
mapAction f action io1 =

promptInt :: String -&gt; Action Int
promptInt msg = mapAction readInt (promptString msg)
```

---

## Exercise 5

* We&#x27;ll do both name and age, with helper functions!
* Fix `ex5-name-and-age.hs`

---

## Exercise 6

* Lots of effort perform two actions
* Let&#x27;s write a helper function!
* `ex6-do-both.hs`

```haskell
inner :: Action ()
inner = doBoth echoName echoAge

doBoth :: Action () -&gt; Action () -&gt; Action ()
doBoth action1 action2 io1 =
```

Challenge: generalize the type signature for `doBoth`

---

## Exercise 7

* Implementation of `echoName` and `echoAge` is tedious
* Let&#x27;s make it less tedious!
* `ex7-and-then.hs`

```haskell
echoName :: Action ()
echoName = andThen
  (promptString &quot;What&#x27;s your name?&quot;)
  print

echoAge :: Action ()
echoAge = andThen
  (promptInt &quot;What&#x27;s your age?&quot;)
  printInt

printInt :: Int -&gt; Action ()
andThen :: Action a -&gt; (a -&gt; Action b) -&gt; Action b
```

---

## Abolish `IOState`

* Let&#x27;s face it: `IOState` is a pain
* Tedious to write code
* Throwing the hack in our face all the time
* Can accidentally reuse previous states
* We have enough machinery to stop using it directly

----

## Our helper functions

```haskell
mapAction :: (a -&gt; b) -&gt; Action a -&gt; Action b
doBoth :: Action a -&gt; Action b -&gt; Action b
andThen :: Action a -&gt; (a -&gt; Action b) -&gt; Action b
```

Looks like we can do everything we need with these.

----

## Hide the `IOState`

* `Action` is just a type alias right now
* Let&#x27;s make it a &quot;newtype&quot; to hide its implementation

```haskell
newtype Action a = Action (IOState -&gt; (IOState, a))
```

* Hide the `Action` &quot;data constructor&quot;
* Now we can&#x27;t play with the `IOState` values directly

----

## Fake exercise 8

* Nothing to do
* Look at `ex8-newtype.hs` to see the difference
* Tada!

---

## You just learned monads

* Sorry, forgot to mention that before
* `mapAction` is &quot;functor map&quot;
* `doBoth` is &quot;applicative next&quot;
* `andThen` is &quot;monadic bind&quot;
* We invented these concepts automatically to meet two constraints
    * Purely functional
    * Not painful
* (Also, I kind of intended to get there)

----

## Real monads

* Using the real monad machinery in Haskell is nicer
* You get `do`-notation
* Let&#x27;s see one final exercise: rewriting to real monads
* Open `ex9-enough-already.hs`

----

## Takeaways

* Monads are a natural way to sequence actions in a purely functional
  language
* However, monads are more general than that!
* We can use the same machinery for other kinds of things
    * This may not have a value (`Maybe`)
    * This carries some extra data (`State`)
* Ultimately, `do`-notation gives us a similar imperative feel, but
  based on purity
* Pure functions provide extra power

---

## Exercise 10

Remember this thingy?

```
x1 = 2 + 3;
x2 = 2 + 3;
x3 = 2 + 3;
x4 = 2 + 3;
y = 4 + 5;
z = x4 * y;
return z;
```

Rewrite it in Haskell! `ex10-extra-computation.hs`

----

## Question

* How many times did your processor calculate `2 + 3`?
* Not easy to prove it
* Let&#x27;s try something else

---

## Exercise 11

Predict the output of this program `ex11-error.hs`

```haskell
main = print inner

inner :: Int
inner =
  let w = error &quot;this is not needed!&quot;
      x = 2 + 3
      y = 4 + 5
   in x * y
```

----

## `w` is not needed

* No data dependency on `w`
* In Haskell, we say that the value is never _forced_
* Therefore: the error is never thrown

----

## Similarly...

What does this mean?

```haskell
main = print inner

inner :: Int
inner =
  let w = print &quot;Hello World!&quot;
      x = 2 + 3
      y = 4 + 5
   in x * y
```

----

## Action vs pure value

* Haskell distinguishes betweens _actions_ and _pure values_
* To perform an action, we have to _sequence it_ (e.g., `do`-notation)
* To evaluate a value, we have to _force it_
* This is a natural outcome of purity
* Values which aren&#x27;t forced are _thunks_, which is _laziness_

---

## Exercise 12

What&#x27;s the output of this program `ex12-lazy-and.hs`

```haskell
myAnd :: Bool -&gt; Bool -&gt; Bool
myAnd True x = x
myAnd False _ = False

main :: IO ()
main = do
  print (myAnd (2 &gt; 1) (3 &gt; 2))
  print (myAnd (2 &gt; 1) (1 &gt; 2))
  print (myAnd (1 &gt; 2) (2 &gt; 1))
  print (myAnd (1 &gt; 2) (2 &gt; undefined))
  print (myAnd (2 &gt; 1) (2 &gt; undefined))
```

----

## Short circuiting for free

* Most languages: `&amp;&amp;` and `||` are special-cased short circuiting
* In Haskell: _everything_ can short circuit like that
* Does require thinking a bit about &quot;is this evaluated here&quot;

---

## Immutability

* Not going into detail here
* Have a rule: function must always return same output for same input
* Consider this function:

```haskell
f :: Int -&gt; Int
f _ = x

x :: Int
x = 5
```

* What happens if `x` can be changed?
* QED Haskell variables must be immutable by default
* Mutable _does_ exist, but we won&#x27;t get into it today

---

## Further info

* What Makes Haskell Unique [Slides](https:&#x2F;&#x2F;www.snoyman.com&#x2F;reveal&#x2F;what-makes-haskell-unique) [Video](https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=DebDaiYev2M&amp;t=1s)
* [Get Started](https:&#x2F;&#x2F;haskell-lang.org&#x2F;get-started)
* [FP Complete Haskell Syllabus](https:&#x2F;&#x2F;www.fpcomplete.com&#x2F;haskell-syllabus)
* [Functors, Applicatives, and Monads](https:&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;01&#x2F;functors-applicatives-and-monads)
* [All About Strictness](https:&#x2F;&#x2F;www.fpcomplete.com&#x2F;blog&#x2F;2017&#x2F;09&#x2F;all-about-strictness) (advanced)


                </section>
            </div>
        </div>

        <script src="/static/reveal/lib/js/head.min.js"></script>
        <script src="/static/reveal/js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: '/static/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: '/static/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: '/static/reveal/plugin/zoom-js/zoom.js', async: true },
              { src: '/static/reveal/plugin/notes/notes.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"center":false,"controls":false};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);
        </script>
    </body>
</html>
