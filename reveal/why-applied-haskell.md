---
title: Why Applied Haskell
---

## Why Applied Haskell

* Quick introduction to why you're here, and why I do this :)
* Ties in with [Applied Haskell 101](https://tech.fpcomplete.com/haskell/tutorial/applied-haskell-101)
* __NOTE__ WIP slides, don't throw things at me!

<div style="text-align:center">
<div><img src="/static/fpcomplete-logo.png" style="border:0;margin:0"></div>
</div>

1. Install Stack! https://tech.fpcomplete.com/haskell/get-started
2. Run `stack upgrade`
3. Run `stack build rio --resolver lts-14.10`

---

## Haskell is revolutionary

* Totally different than other languages
* Lots of new concepts to absorb
* 15 exciting ways to solve problems
* Powers you never had elsewhere

---

## Haskell is powerful

* Our goal: write normal, boring programs in Haskell
* Get benefits of:
    * Stronger types
    * Better performance
    * Better productivity
    * Refactorable code
    * Team scaling

---

## Haskell is a problem

* How do I do all of that?
* Most new Haskellers/Haskell teams reinvent the wheel
* Lots of paths seem alluring and stab you in the back
* General wisdom in Haskell discussion boards is dangerous

---

## Haskell is boring

* We're going to write boring Haskell
* Take the best revolutionary stuff
* Combine with practices and libraries that are boring
* Big value from today: identifying where to be boring, where to be exciting

---

## Haskell is mundane

* Rest of the world is borrowing from Haskell
* Some of Haskell's craziest things are commonplace
    * Anecdate: JS devs, Rust, and monads
* It's becoming ever easier to onboard people to Haskell
* Haskell's types make onboarding to codebases easier
* But you have to make your code approachable!

---

## But I need this cool feature!

* You probably don't
* Most of us have been there
* Far too easy to have fun and go off the deep end
* Strong recommendation: try solving the easy way first
