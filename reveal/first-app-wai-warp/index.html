<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Your first Haskell web app with WAI and Warp</title>
        <link rel="stylesheet" href="/static/reveal/css/reveal.css">
        <link rel="stylesheet" href="/static/reveal/css/theme/black.css" id="theme">
        <link rel="stylesheet" href="/static/reveal/css/highlight/zenburn.css">
        <link rel="stylesheet" href="/static/reveal/css/print/paper.css" type="text/css" media="print">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown data-separator="^\r?\n---\r?\n$" data-separator-vertical="^\r?\n----\r?\n$">
                  

## Your first Haskell web app with WAI and Warp

* Michael Snoyman
* VP Engineering, FP Complete&lt;br&gt;&lt;img alt=&quot;FP Complete logo&quot; src=&quot;https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;images&#x2F;fp-complete-logo-small.png&quot; style=&quot;border:0&quot;&gt;
* Functional Conf 2019
* Friday, November 15, 2019

---

## Why WAI?

* Web Application Interface - pronounced &quot;why&quot;
* I wanted to do web development in Haskell
* Didn&#x27;t want to have to maintain my own web server (hah!)
* Interface shared among multiple frameworks
* Swap out backends: real server, testing, CGI (for fellow dinosaurs)
* Middlewares (gzip, logging, etc)

---

## Hello WAI!

```haskell
#!&#x2F;usr&#x2F;bin&#x2F;env stack
-- stack --resolver lts-14.10 script
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.Wai.Handler.Warp (run)
import Network.HTTP.Types (status200)

main :: IO ()
main = run 3000 $ \_req send -&gt;
  send $ responseBuilder
    status200
    [(&quot;Content-Type&quot;, &quot;text&#x2F;plain; charset=utf-8&quot;)]
    &quot;Hello World from WAI!&quot;
```

We&#x27;ll discuss all of this (and more!) in this talk

---

## Goals

* Minimal overhead
* Unopinionated
* Extensible
* Stable
* Batteries not included, but available

---

## Common packages

* `wai`: core data types, a few utilities
* `warp`: de facto standard server
* `wai-extra`: common middlewares and helpers
* `wai-conduit`: conduit-specific streaming support
* `pipes-wai`: pipes-specific streaming support
* `wai-websockets`: you can probably guess :)

---

## Data types

```haskell
-- Given to you by the backend
data Request

-- Smart constructors, we&#x27;ll show &#x27;em later
data Response

-- Doesn&#x27;t actually exist
type SimpleApp = Request -&gt; IO Response

-- More complicated, we&#x27;ll get to it
type Application = ...

type Middleware = Application -&gt; Application
```

---

## Minimal parsing

`Request` has fields like:

```haskell
data Request = Request
  { rawPathInfo    :: ByteString
  , rawQueryString :: ByteString
  , pathInfo       :: [Text]
  , queryString    :: [(ByteString, Maybe ByteString)]
  , ...
  }
```

Covers GET parameters, but how about post parameters?

```haskell
getRequestBodyChunk :: Request -&gt; IO ByteString
```

And use `wai-extra` to actually parse the body

---

## Response smart constructors

Use a lazy ByteString

```haskell
responseLBS
  :: Status
  -&gt; [ResponseHeader]
  -&gt; LazyByteString
  -&gt; Response
```

Or better: use a Builder

```haskell
responseBuilder
  :: Status
  -&gt; [ResponseHeader]
  -&gt; Builder
  -&gt; Response
```

Efficient buffer filling, can reduce memory copying and system call overhead!

---

## Response from a file

* Some backends (like Warp) can use the `sendfile` system call
* Bypasses buffer copies&#x2F;system calls
* Other backends may need to fall back to `read`ing the file

```haskell
responseFile
  :: Status
  -&gt; [ResponseHeader]
  -&gt; FilePath
  -&gt; Maybe FilePart -- send a few pieces
  -&gt; Response
```

Yesod, `wai-app-static`, others call this for you

---

## Streaming and `Application`

* Just want a `Request -&gt; IO Response`
* However, need to handle streaming data cases
* Example warranted (most complicated thing today)

```haskell
type SimpleApp = Request -&gt; IO Response
simpleRun :: Int -&gt; SimpleApp -&gt; IO ()

main =
  simpleRun 8000 $ \_req -&gt;
  withBinaryFile &quot;big-file.csv&quot; ReadMode $ \h -&gt; do
    lbs &lt;- BL.hGetContents h -- lazy read!
    pure $ responseLBS
      status200
      [(&quot;Content-Type&quot;, &quot;text&#x2F;csv; charset=utf-8&quot;)]
      lbs
```

Who can find the bug?

---

## Extend the bracket!

* Need to run `withBinaryFile` outside of the response sending
* So we provide a `send` callback

```haskell
main :: IO ()
main =
  run 8000 $ \_req send -&gt;
  withBinaryFile &quot;big-file.csv&quot; ReadMode $ \h -&gt; do
    lbs &lt;- BL.hGetContents h
    send $ responseLBS
      status200
      [(&quot;Content-Type&quot;, &quot;text&#x2F;csv; charset=utf-8&quot;)]
      lbs
```

Let&#x27;s compare side by side

---

## Did you miss it?

### Bad

```haskell
withBinaryFile &quot;big-file.csv&quot; ReadMode $ \h -&gt; do
  lbs &lt;- BL.hGetContents h -- lazy read!
  pure $ responseLBS
    status200
    [(&quot;Content-Type&quot;, &quot;text&#x2F;csv; charset=utf-8&quot;)]
    lbs
```

### Good

```haskell
withBinaryFile &quot;big-file.csv&quot; ReadMode $ \h -&gt; do
  lbs &lt;- BL.hGetContents h -- still lazy, but OK
  send $ responseLBS
    status200
    [(&quot;Content-Type&quot;, &quot;text&#x2F;csv; charset=utf-8&quot;)]
    lbs
```

---

## ResponseReceived trick

Want `send` to be called exactly once

```haskell
-- Data constructor only exported in internal module
data ResponseReceived = ResponseReceived

type Send = Response -&gt; IO ResponseReceived
type Application = Request -&gt; Send -&gt; IO ResponseReceived
```

* Warp and other backends use the internal module
* Normal apps _must_ call send to get a `ResponseReceived` value
* They can still cheat and call it twice... we don&#x27;t have linear types

---

## Continuous Passing Style

&lt;img src=&quot;&#x2F;static&#x2F;yo-dawg-cps.jpeg&quot;&gt;

_Done with the hard part!_

---

## Routing

Use `pathInfo`, handles splitting, char encoding, etc.

```haskell
main = do
  run 8000 $ \req send -&gt; do
    let okHelper = send . responseBuilder status200 []
    case pathInfo req of
      [] -&gt; okHelper &quot;Home page&quot;
      [&quot;foo&quot;] -&gt; okHelper &quot;&#x2F;foo&quot;
      [&quot;foo&quot;, &quot;bar&quot;] -&gt; okHelper &quot;&#x2F;foo&#x2F;bar&quot;
      _ -&gt; send $ responseBuilder status404 [] &quot;Not found&quot;
```

* Can route on query string parameters too
* Need to parse the request body to get post parameters

---

## Logging

Hello Middleware!

```haskell
hello :: Application
hello _req send =
  send $ responseBuilder status200 [] &quot;Hello!&quot;

loggedHello :: Application
loggedHello = logStdout hello

main :: IO ()
main = run 8000 loggedHello
```

Lots of additional options for output dest, display, etc

---

## Write our own middleware

```haskell
chaos :: Middleware
chaos app req send = do
  let newReq = req { pathInfo = &quot;marauder&quot; : pathInfo req }
  putStrLn &quot;I am up to no good&quot;
  output &lt;- app newReq send
  putStrLn &quot;Mischief managed&quot;
  pure output

main :: IO ()
main = run 8000 $ chaos loggedHello
```

* Perform actions before and after app
* Modify information app receives
* Can be layered with other middleware

---

## Virtual hosts (1)

Can make decisions based on headers as well

```haskell
main :: IO ()
main = run 8000 $ \req send -&gt;
  send $ responseBuilder status200 [] $
  case lookup &quot;host&quot; $ requestHeaders req of
    Nothing -&gt; &quot;No host header found&quot;
    Just host -&gt; &quot;Host is &quot; &lt;&gt; byteString host
```

Or even better: different apps...

---

## Virtual hosts (2)

Serve different apps per domain

```haskell
main = run 8000 $ \req send -&gt;
  case lookup &quot;host&quot; $ requestHeaders req of
    Just &quot;www.example.com&quot; -&gt; app1 req send
    Just &quot;www.example.org&quot; -&gt; app2 req send
    Nothing -&gt;
      send $ responseBuilder status400 [] &quot;No host&quot;
    Just host -&gt;
      send $ responseBuilder status400 [] $
      &quot;Unknown host: &quot; &lt;&gt; byteString host
```

Pass in the `req` and `send` to the sub-apps

---

## Ready-to-go apps

Want a static file server?

```haskell
#!&#x2F;usr&#x2F;bin&#x2F;env stack
-- stack --resolver lts-14.10 script
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.RequestLogger
import Network.Wai.Application.Static

main :: IO ()
main = run 8000 $ logStdout $ staticApp $
       defaultFileServerSettings &quot;content&quot;
```

* And we got logging
* Check out `wai-middleware-auth` to secure it
* Can combine with a Yesod app using virtual hosts

---

## Deployment overview

* Commonly use Warp as backend
* Reverse proxy from nginx, Kubernetes, AWS load balancer
* Can listen on user-facing port as well
* `warp-tls` provides pure-Haskell secure deployment option
* Can even go retro and use CGI
* Haskell apps compile to machine executable, copy to machine
* Or use something like Docker to package it all up

---

## Deployment example caveat

* Don&#x27;t do what I&#x27;m about to show you
* No good reason to package up multiple apps like this
* Kubernetes can handle the load balancing better

&lt;img src=&quot;https:&#x2F;&#x2F;www.fpcomplete.com&#x2F;static&#x2F;hysterical-raisins.jpg&quot; height=&quot;300&quot;&gt;

---

## Deployment example - snoyman-webapps

* Two webapps (snoyman.com and yesodweb.com)
* Third app as reverse proxy in front of them
    * Uses `http-reverse-proxy`
* Reverse proxy app launches and keeps other two running
* Gitlab CI builds all three, packages into a Docker image

---

## build-docker.sh

```shell
mkdir -p \
  docker&#x2F;artifacts&#x2F;app&#x2F;yesodweb.com \
  docker&#x2F;artifacts&#x2F;app&#x2F;webapps \
  docker&#x2F;artifacts&#x2F;bin
stack install --local-bin-path docker&#x2F;artifacts&#x2F;bin
cp -r sites&#x2F;yesodweb.com&#x2F;config sites&#x2F;yesodweb.com&#x2F;static \
  docker&#x2F;artifacts&#x2F;app&#x2F;yesodweb.com
cp -r webapps&#x2F;config docker&#x2F;artifacts&#x2F;app&#x2F;webapps
docker build --tag snoyberg&#x2F;snoyman-webapps docker
```

---

## Dockerfile

```
FROM fpco&#x2F;pid1:18.04

RUN export DEBIAN_FRONTEND=noninteractive &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install -y git &amp;&amp; \
    apt-get clean &amp;&amp; \
    unset DEBIAN_FRONTEND

COPY artifacts&#x2F;bin &#x2F;usr&#x2F;local&#x2F;bin
COPY artifacts&#x2F;app&#x2F; &#x2F;app
```

* Uses `git` at runtime
* `fpco&#x2F;pid1` provides zombie prevention and more

---

## .gitlab-ci.yml

```yaml
build:
  stage: build
  script:
    - docker&#x2F;build-docker.sh
    - docker tag snoyberg&#x2F;snoyman-webapps &quot;${IMGNAME}&quot;

deploy:
  stage: deploy
  only:
    - master
  script:
    - kubectl set image &quot;$KUBENAME&quot; webapps=&quot;$IMGNAME&quot;
    - kubectl rollout status &quot;$KUBENAME&quot;
```

---

## Exception handling

* Warp has a fallback exception handler
* Don&#x27;t rely on it
* Applications should _not_ throw exceptions
    * Middlewares will break!
    * Yesod does rigorous exception catching for you
* Catch exceptions, log them, return error pages
* Be [async exception safe](https:&#x2F;&#x2F;tech.fpcomplete.com&#x2F;blog&#x2F;2018&#x2F;04&#x2F;async-exception-handling-haskell)

---

## Demo: JSON service

* Keep a map of name&#x2F;age pairs
* Get list of all names
* Query individuals
* Two ways to add values:
    * PUT with query string to set age
    * POST with request body

[Full code available on Github](https:&#x2F;&#x2F;gist.github.com&#x2F;snoyberg&#x2F;6172d8da3fe145d9c80aaa7d495b74e3)

---

## API overview

* `GET &#x2F;people`
    * JSON array of names
* `POST &#x2F;people`
    * URL encoded body, requires `name` and `age`
* `GET &#x2F;person&#x2F;&lt;name&gt;`
    * `{&quot;name&quot;:&quot;&lt;name&gt;&quot;,&quot;age&quot;:&lt;age&gt;}`
* `PUT &#x2F;person&#x2F;&lt;name&gt;?age=&lt;age&gt;`

---

## Type synonyms

```haskell
-- Type synonyms for nicer signatures below
type Name = Text
type Age = Int
type PeopleMap = Map Name Age
type PeopleVar = TVar PeopleMap
```

---

## Response helpers

```haskell
-- Common error responses
notFound :: Response
notFound = responseBuilder status404 [] &quot;Not found&quot;

badRequest :: Response
badRequest = responseBuilder status405 [] &quot;Bad req method&quot;

-- | Build a successful JSON response
jsonResponse :: ToJSON a =&gt; a -&gt; Response
jsonResponse = responseBuilder
  status200
  [(hContentType, &quot;application&#x2F;json&quot;)]
  . fromEncoding . toEncoding
```

---

## Router

```haskell
peopleApp :: PeopleVar -&gt; Application
peopleApp peopleVar req send = do
  response &lt;-
    case pathInfo req of
      [&quot;people&quot;] -&gt;
        case requestMethod req of
          &quot;GET&quot; -&gt; getPeopleResponse peopleVar
          &quot;POST&quot; -&gt; postPeopleResponse peopleVar req
          _ -&gt; pure badRequest
```

```haskell
      [&quot;person&quot;, name] -&gt;
        case requestMethod req of
          &quot;GET&quot; -&gt; getPersonResponse peopleVar name
          &quot;PUT&quot; -&gt; do
            let ageParam = lookup &quot;age&quot; $ queryString req
            putPersonResponse peopleVar name ageParam
      _ -&gt; pure notFound
  send response
```

---

## Getters

```haskell
getPeopleResponse :: PeopleVar -&gt; IO Response
getPeopleResponse peopleVar = do
  people &lt;- atomically $ readTVar peopleVar
  pure $ jsonResponse $ Map.keys people

getPersonResponse :: PeopleVar -&gt; Name -&gt; IO Response
getPersonResponse peopleVar name = do
  people &lt;- atomically $ readTVar peopleVar
  case Map.lookup name people of
    Nothing -&gt; pure notFound
    Just age -&gt; pure $ jsonResponse $ object
      [ &quot;name&quot; .= name
      , &quot;age&quot; .= age
      ]
```

---

## Set via PUT

```haskell
putPersonResponse
  :: PeopleVar -&gt; Name -&gt; Maybe (Maybe ByteString)
  -&gt; IO Response
putPersonResponse _ _ Nothing =
  pure $ responseBuilder status400 [] &quot;No age parameter&quot;
putPersonResponse _ _ (Just Nothing) =
  pure $ responseBuilder status400 [] &quot;Empty age parameter&quot;
```

```haskell
putPersonResponse peopleVar name (Just (Just bs)) =
  case Lex.readDecimal bs of
    Just (age, &quot;&quot;) -&gt; do
      atomically $ modifyTVar&#x27; peopleVar
                 $ Map.insert name age
      pure $ responseBuilder status201 [] &quot;&quot;
    _ -&gt; pure $ responseBuilder status400 []
                &quot;Invalid age parameter&quot;
```

---

## Set via POST

```haskell
postPeopleResponse :: PeopleVar -&gt; Request -&gt; IO Response
postPeopleResponse peopleVar req = do
  (params, _) &lt;- parseRequestBody lbsBackEnd req
  let mpair = do
        nameBS &lt;- lookup &quot;name&quot; params
        name &lt;- either (const Nothing) Just $
                decodeUtf8&#x27; nameBS
        ageBS &lt;- lookup &quot;age&quot; params
        (age, &quot;&quot;) &lt;- Lex.readDecimal ageBS
        Just (name, age)
```

```haskell
  case mpair of
    Just (name, age) -&gt; do
      atomically $ modifyTVar&#x27; peopleVar
                 $ Map.insert name age
      pure $ responseBuilder status201 [] &quot;&quot;
    Nothing -&gt; pure $ responseBuilder status400 []
                      &quot;Invalid parameters&quot;
```

---

## Main function

```haskell
main :: IO ()
main = do
  peopleVar &lt;- newTVarIO mempty
  run 8000 $ logStdout $ autohead $ peopleApp peopleVar
```

Check out the test script in the Gist above

---

## Takeaways

* Perfectly doable to write an app directly with WAI
* Lots of manual plumbing
* Web frameworks handle these things for you

---

## Summary

* WAI is a low level interface
* Basis for many frameworks and some apps
* Lots of common utilities
* Easy to plumb together lots of things
* Probably not the interface you&#x27;ll use on a daily basis
* But totally usable if you need it

Questions? Thank you!


                </section>
            </div>
        </div>

        <script src="/static/reveal/lib/js/head.min.js"></script>
        <script src="/static/reveal/js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: '/static/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: '/static/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: '/static/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: '/static/reveal/plugin/zoom-js/zoom.js', async: true },
              { src: '/static/reveal/plugin/notes/notes.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"center":false,"controls":false};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);
        </script>
    </body>
</html>
