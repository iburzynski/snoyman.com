
    

<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <title>Tokio 0.2 - Rust Crash Course lesson 9</title>

    <meta name="twitter:site" content="@snoyberg">
    <meta name="twitter:creator" content="@snoyberg">
    <meta name="og:site_name" content="Michael Snoyman's homepage">
    <meta name="og:title" content="Tokio 0.2 - Rust Crash Course lesson 9">
    <meta name="og:type content="website">

    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"> 
    <link rel="stylesheet" href="/maxi/vendors/font-awesome/css/fontawesome-all.min.css">
    <link rel="stylesheet" type="text/css" href="/maxi/css/styles.css">

    

<meta name="og:description" value="Lesson 9 in the Rust crash course: using Tokio 0.2.
">






    <link rel="openid2.provider" href="https://openid.stackexchange.com/openid/provider">
    <link rel="openid2.local_id" href="https://openid.stackexchange.com/user/d26546d2-46db-4099-83ca-e1eccfa0dd8d">
    <link href="/rss.xml" type="application/atom+xml" rel="alternate" title="Michael Snoyman's blog">

    <style>.wt-section { padding-top: 2rem }</style>
  <body>
    <header class="inner-page">
      

<nav class="js-navbar-scroll navbar fixed-top navbar-expand-lg">
  <div class="container-fluid">
    <a class="navbar-brand" href="/">
      <img src="/img/snoylogo.png" height="50px">
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo" aria-controls="navbarTogglerDemo" aria-expanded="false" aria-label="Toggle navigation">
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse onCollapse" id="navbarTogglerDemo">
      <ul class="navbar-nav ml-auto mt-2 mt-lg-0">
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="/blog">Blog</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.yesodweb.com/">Yesod</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="http://shop.oreilly.com/product/0636920035664.do">Yesod Book</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.beginrust.com/">Rust Book</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.youtube.com/c/snoyberg">YouTube</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://twitter.com/snoyberg">Twitter</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://github.com/snoyberg">Github</a>
        </li>
      </ul>
    </div>
  </div>
</nav>



      <section class="wt-section bg-gray text-center inner-page-header" style="padding-top:100px">
        <div class="container">
          <div class="row justify-content-md-center align-items-center text-white py-lg-5">
            <div class="col-md-7">
              <div class="text-center">
                <h1 class="display-sm-4 display-lg-3">Tokio 0.2 - Rust Crash Course lesson 9</h1>
                
<p class="h6 text-uppercase wt-letter-spacing-sm mb-0">Published December  5, 2019</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </header>

    <main role="main">
      <section class="wt-section">
        <div class="container">
          <div class="row justify-content-between">
            <div class="col-lg-12">
              <p class="text-center">
                <a class="btn" style="background: #72472f; color: #fff; font-weight: bold" href="https://www.beginrust.com/">New: The "Begin Rust" book</a>
              </p>

              




  


<div class="share-bar-wrapper">
  <div class="share-bar-inner">
    <b>Share this</b>
    <a target="_blank" href="https://twitter.com/intent/tweet?text=Tokio%200.2%20-%20Rust%20Crash%20Course%20lesson%209 https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2019&#x2F;12&#x2F;rust-crash-course-09-tokio-0-2&#x2F;" title="Share on Twitter">
      <i class="fab fa-twitter"></i>
    </a>

    <a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2019&#x2F;12&#x2F;rust-crash-course-09-tokio-0-2&#x2F;" title="Share on Facebook">
      <i class="fab fa-facebook"></i>
    </a>

    <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2019&#x2F;12&#x2F;rust-crash-course-09-tokio-0-2&#x2F;&amp;title=Tokio%200.2%20-%20Rust%20Crash%20Course%20lesson%209" title="Share on LinkedIn">
      <i class="fab fa-linkedin"></i>
    </a>

    <a target="_blank" href="https://www.reddit.com/submit?url=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2019&#x2F;12&#x2F;rust-crash-course-09-tokio-0-2&#x2F;" title="Share on Reddit">
      <i class="fab fa-reddit"></i>
    </a>
  </div>
</div>



<!--
<div class="container" id="blog-body">
  <div class="row">
    <div class="col-lg-9">
-->
      <p>
        <i>
          See a typo? Have a suggestion?
          <a target="_blank" rel="nofollow" href="https://github.com/snoyberg/snoyman.com/edit/master/content/blog&#x2F;rust-crash-course-09-tokio-0-2.md">Edit this page on Github</a>
        </i>
      </p>

      <p><strong>Heads up</strong> This blog post series has been updated and published as an eBook by FP Complete. I'd recommend reading that version instead of these posts. If you're interested, please check out the <a href="https://www.fpcomplete.com/rust/crash-course/">Rust Crash Course eBook</a>.</p>
<p>In the <a href="/blog/2019/12/rust-crash-course-08-down-dirty-future">previous lesson in the crash course</a>, we covered the new <code>async/.await</code> syntax stabilized in Rust 1.39, and the <code>Future</code> trait which lives underneath it. This information greatly supercedes the now-defunct lesson 7 from last year, which covered the older <code>Future</code> approach.</p>
<p>Now it's time to update the second half of lesson 7, and teach the hot-off-the-presses Tokio 0.2 release. For those not familiar with it, let me quote the project's overview:</p>
<blockquote>
<p>Tokio is an event-driven, non-blocking I/O platform for writing asynchronous applications with the Rust programming language.</p>
</blockquote>
<p>If you want to write an efficient, concurrent network service in Rust, you'll want to use something like Tokio. That's not to say that this is the only use case for Tokio; you can do lots of great things with an event driven scheduler outside of network services. It's also not to say that Tokio is the only solution; the <a href="https://async.rs/"><code>async-std</code></a> library provides similar functionality.</p>
<p>However, network services are likely the most common domain agitating for a non-blocking I/O system. And Tokio is the most popular and established of these systems today. So this combination is where we're going to get started.</p>
<p>And as a side note, if you have some other topic you'd like me to cover around this, please <a href="https://twitter.com/snoyberg">let me know on Twitter</a>.</p>
<p><em>Exercise solutions will be included at the end of the blog post. Yes, I keep changing the rules, sue me.</em></p>
<p>This post is part of a series based on <a href="https://tech.fpcomplete.com/rust">teaching Rust at FP
Complete</a>. If you're reading this post outside
of the blog, you can find links to all posts in the series <a href="https://www.snoyman.com/blog/2018/10/introducing-rust-crash-course">at the top of the
introduction
post</a>. You
can also <a href="https://www.snoyman.com/feed/rust-crash-course">subscribe to the RSS
feed</a>.</p>
<h2 id="hello-tokio">Hello Tokio!</h2>
<p>Let's kick this off. Go ahead and create a new Rust project for experimenting:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">$ cargo new --bin usetokio
</span></code></pre>
<p>If you want to make sure you're using the same compiler version as me, set up your <code>rust-toolchain</code> correctly:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">$ echo 1.39.0 &gt; rust-toolchain
</span></code></pre>
<p>And then set up Tokio as a dependency. For simplicity, we'll install all the bells and whistles. In your <code>Cargo.toml</code>:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">[</span><span style="color:#b58900;">dependencies</span><span style="color:#657b83;">]
</span><span style="color:#268bd2;">tokio </span><span style="color:#657b83;">= { </span><span style="color:#268bd2;">version </span><span style="color:#657b83;">= </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">0.2</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, </span><span style="color:#268bd2;">features </span><span style="color:#657b83;">= [</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">full</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">] }
</span></code></pre>
<p><strong>PROTIP</strong> You can run <code>cargo build</code> now to kick off the download and build of crates while you keep reading...</p>
<p>And now we're going to write an asynchronous hello world application. Type this into your <code>src/main.rs</code>:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout = io::stdout();
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> hello: </span><span style="color:#859900;">&amp;</span><span style="color:#657b83;">[</span><span style="color:#268bd2;">u8</span><span style="color:#657b83;">] = </span><span style="color:#268bd2;">b</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Hello, world!</span><span style="color:#dc322f;">\n</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">;
    io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> hello, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p><strong>NOTE</strong> I specifically said &quot;type this in&quot; instead of &quot;copy and paste.&quot; For getting comfortable with this stuff, I recommend manually typing in the code.</p>
<p>A lot of this should look familiar from our previous lesson. To recap:</p>
<ul>
<li>Since we'll be <code>await</code>ing something and generating a <code>Future</code>, our <code>main</code> function is <code>async</code>.</li>
<li>Since <code>main</code> is <code>async</code>, we need to use an executor to run it. That's why we use the <code>#[tokio::main]</code> attribute.</li>
<li>Since performing I/O can fail, we return a <code>Result</code>.</li>
</ul>
<p>The first really new thing since last lesson is this little bit of syntax:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">.await</span><span style="color:#859900;">?
</span></code></pre>
<p>I mentioned it last time, but now we're seeing it in real life. This is just the combination of our two pieces of prior art: <code>.await</code> for chaining together <code>Future</code>s, and <code>?</code> for error handling. The fact that these work together so nicely is really awesome. I'll probably mention this a few more times, because I love it that much.</p>
<p>The next thing to note is that we use <code>tokio::io::stdout()</code> to get access to some value that lets us interact with standard output. If you're familiar with it, this looks really similar to <code>std::io::stdout()</code>. That's by design: a large part of the <code>tokio</code> API is simply async-ifying things from <code>std</code>.</p>
<p>And finally, we can look at the actual <code>tokio::io::copy</code> call. As you may have guessed, and as stated in the <a href="https://docs.rs/tokio/0.2.2/tokio/io/fn.copy.html">API docs</a>:</p>
<blockquote>
<p>This is an asynchronous version of <a href="https://doc.rust-lang.org/std/io/fn.copy.html"><code>std::io::copy</code></a>.</p>
</blockquote>
<p>However, instead of working with the <code>Read</code> and <code>Write</code> traits, this works with their async cousins: <code>AsyncRead</code> and <code>AsyncWrite</code>. A byte slice (<code>&amp;[u8]</code>) is a valid <code>AsyncRead</code>, so we're able to store our input there. And as you may have guessed, <code>Stdout</code> is an <code>AsyncWrite</code>.</p>
<p><strong>EXERCISE 1</strong> Modify this application so that instead of printing &quot;Hello, world!&quot;, it copies the entire contents of standard input to standard output.</p>
<p><strong>NOTE</strong> You can simplify this code using <code>stdout.write_all</code> after <code>use</code>ing <code>tokio::io::AsyncWriteExt</code>, but we'll stick to <code>tokio::io::copy</code>, since we'll be using it throughout. But if you're curious:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io::{</span><span style="color:#d33682;">self</span><span style="color:#657b83;">, AsyncWriteExt};

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout = io::stdout();
    stdout.</span><span style="color:#859900;">write_all</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">b</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Hello, world!</span><span style="color:#dc322f;">\n</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre><h2 id="spawning-processes">Spawning processes</h2>
<p>Tokio provides a <code>tokio::process</code> module which resembles the <code>std::process</code> module. We can use this to implement Hello World once again:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::process::Command;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">echo</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">arg</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Hello, world!</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>Notice how the <code>?</code> and <code>.await</code> bits can go in whatever order they are needed. You can read this line as:</p>
<ul>
<li>Create a new <code>Command</code> to run <code>echo</code></li>
<li>Give it the argument <code>&quot;Hello, world!&quot;</code></li>
<li>Spawn this, which may fail</li>
<li>Using the first <code>?</code>: if it fails, return the error. Otherwise, return a <code>Future</code></li>
<li>Using the <code>.await</code>: wait until that <code>Future</code> completes, and capture its <code>Result</code></li>
<li>Using the second <code>?</code>: if that <code>Result</code> is <code>Err</code>, return that error.</li>
</ul>
<p>Pretty nice for a single line!</p>
<p>One of the great advantages of <code>async</code>/<code>.await</code> versus the previous way of doing async with callbacks is how easily it works with looping.</p>
<p><strong>EXERCISE 2</strong> Extend this example so that it prints <code>Hello, world!</code> 10 times.</p>
<h2 id="take-a-break">Take a break</h2>
<p>So far we've only really done a single bit of <code>.await</code>ing. But it's easy enough to <code>.await</code> on multiple things. Let's use <a href="https://docs.rs/tokio/0.2.2/tokio/time/fn.delay_for.html"><code>delay_for</code></a> to pause for a bit.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::time;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::process::Command;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">std::time::Duration;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">date</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    time::delay_for(Duration::from_secs(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)).await;
    Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">date</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    time::delay_for(Duration::from_secs(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)).await;
    Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">date</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>We can also use the <code>tokio::time::interval</code> function to create a stream of &quot;ticks&quot; for each time a certain amount of time has passed. For example, this program will keep calling <code>date</code> once per second until it is killed:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::time;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::process::Command;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">std::time::Duration;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> interval = time::interval(Duration::from_secs(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">));
    </span><span style="color:#859900;">loop </span><span style="color:#657b83;">{
        interval.</span><span style="color:#859900;">tick</span><span style="color:#657b83;">().await;
        Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">date</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    }
}
</span></code></pre>
<p><strong>EXERCISE 3</strong> Why isn't there a <code>Ok(())</code> after the <code>loop</code>?</p>
<h2 id="time-to-spawn">Time to spawn</h2>
<p>This is all well and good, but we're not really taking advantage of asynchronous programming at all. Let's fix that! We've seen two different interesting programs:</p>
<ol>
<li>Infinitely pausing 1 seconds and calling <code>date</code></li>
<li>Copying all input from <code>stdin</code> to <code>stdout</code></li>
</ol>
<p>It's time to introduce <code>spawn</code> so that we can combine these two into one program. First, let's demonstrate a trivial usage of <code>spawn</code>:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">std::time::Duration;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::process::Command;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::task;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::time;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    task::spawn(</span><span style="color:#859900;">dating</span><span style="color:#657b83;">()).await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}

async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">dating</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> interval = time::interval(Duration::from_secs(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">));
    </span><span style="color:#859900;">loop </span><span style="color:#657b83;">{
        interval.</span><span style="color:#859900;">tick</span><span style="color:#657b83;">().await;
        Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">date</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    }
}
</span></code></pre>
<p>You may be wondering: what's up with that <code>??</code> operator? Is that some special super-error handler? No, it's just the normal error handling <code>?</code> applied twice. Let's look at some type signatures to help us out here:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#586e75;">pub </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">spawn</span><span style="color:#657b83;">&lt;T&gt;(</span><span style="color:#268bd2;">task</span><span style="color:#657b83;">: T) -&gt; JoinHandle&lt;</span><span style="color:#268bd2;">T::</span><span style="color:#657b83;">Output&gt;;

</span><span style="color:#268bd2;">impl</span><span style="color:#657b83;">&lt;T&gt; Future </span><span style="color:#859900;">for </span><span style="color:#b58900;">JoinHandle</span><span style="color:#657b83;">&lt;T&gt; {
    </span><span style="color:#268bd2;">type </span><span style="color:#b58900;">Output </span><span style="color:#657b83;">= </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;T, JoinError&gt;;
}
</span></code></pre>
<p>Calling <code>spawn</code> gives us back a <code>JoinHandle&lt;T::Output&gt;</code>. In our case, the <code>Future</code> we provide as input is <code>dating()</code>, which has an output of type <code>Result&lt;(), std::io::Error&gt;</code>. So that means the type of <code>task::spawn(dating())</code> is <code>JoinHandle&lt;Result&lt;(), std::io::Error&gt;&gt;</code>.</p>
<p>We also see that <code>JoinHandle</code> implements <code>Future</code>. So when we apply <code>.await</code> to this value, we end up with whatever that <code>type Output = Result&lt;T, JoinError&gt;</code> thing is. Since we know that <code>T</code> is <code>Result&lt;(), std::io::Error&gt;</code>, this means we end up with <code>Result&lt;Result&lt;(), std::io::Error&gt;, JoinError&gt;</code>.</p>
<p>The first <code>?</code> deals with the outer <code>Result</code>, exiting with the <code>JoinError</code> on an <code>Err</code>, and giving us a <code>Result&lt;(), std::io::Error&gt;</code> value on <code>Ok</code>. The second <code>?</code> deals with the <code>std::io::Error</code>, giving us a <code>()</code> on <code>Ok</code>. Whew!</p>
<p><strong>EXERCISE 4</strong> Now that we've seen <code>spawn</code>, you should modify the program so that it calls both <code>date</code> in a loop, and copies <code>stdin</code> to <code>stdout</code>.</p>
<h2 id="synchronous-code">Synchronous code</h2>
<p>You may not have the luxury of interacting exclusively with <code>async</code>-friendly code. Maybe you have some really nice library you want to leverage, but it performs blocking calls internally. Fortunately, Tokio's got you covered with the <a href="https://docs.rs/tokio/0.2.2/tokio/task/fn.spawn_blocking.html"><code>spawn_blocking</code></a> function. Since the docs are so perfect, let me quote them:</p>
<blockquote>
<p>The <code>task::spawn_blocking</code> function is similar to the <code>task::spawn</code> function discussed in the previous section, but rather than spawning an <code>non-blocking</code> future on the Tokio runtime, it instead spawns a <code>blocking</code> function on a dedicated thread pool for blocking tasks.</p>
</blockquote>
<p><strong>EXERCISE 5</strong> Rewrite the <code>dating()</code> function to use <code>spawn_blocking</code> and <code>std::thread::sleep</code> so that it calls <code>date</code> approximately once per second.</p>
<h2 id="let-s-network">Let's network!</h2>
<p>I could keep stepping through the other cools functions in the Tokio library. I encourage you to poke around at them yourself. But I promised some networking, and by golly, I'm gonna deliver!</p>
<p>I'm going to slightly extend the example from the <a href="https://docs.rs/tokio/0.2.2/tokio/net/struct.TcpListener.html#examples"><code>TcpListener</code> docs</a> to (1) make it compile and (2) implement an echo server. This program has a pretty major flaw in it though, I recommend trying to find it.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::net::{TcpListener, TcpStream};

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; io::</span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;()&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> listener = TcpListener::bind(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">127.0.0.1:8080</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;

    </span><span style="color:#859900;">loop </span><span style="color:#657b83;">{
        </span><span style="color:#268bd2;">let </span><span style="color:#657b83;">(socket, </span><span style="color:#859900;">_</span><span style="color:#657b83;">) = listener.</span><span style="color:#859900;">accept</span><span style="color:#657b83;">().await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
        </span><span style="color:#859900;">echo</span><span style="color:#657b83;">(socket).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    }
}

async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">echo</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">socket</span><span style="color:#657b83;">: TcpStream) -&gt; io::</span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;()&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#657b83;">(</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> recv, </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> send) = io::split(socket);
    io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> recv, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> send).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>We use <code>TcpListener</code> to bind a socket. The binding itself is asynchronous, so we use <code>.await</code> to wait for the listening socket to be available. And we use <code>?</code> to deal with any errors while binding the listening socket.</p>
<p>Next, we loop forever. Inside the loop, we accept new connections, using <code>.await?</code> like before. We capture the <code>socket</code> (ignoring the address as the second part of the tuple). Then we call our <code>echo</code> function and <code>.await</code> it.</p>
<p>Within <code>echo</code>, we use <code>tokio::io::split</code> to split up our <code>TcpStream</code> into its constituent read and write halves, and then pass those into <code>tokio::io::copy</code>, as we've done before.</p>
<p>Awesome! Where's the bug? Let me ask you a question: what <em>should</em> the behavior be if a second connection comes in while the first connection is still active? Ideally, it would be handled. However, our program has just one task. And that task <code>.await</code>s on each call to <code>echo</code>. So our second connection won't be serviced until the first one closes.</p>
<p><strong>EXERCISE 6</strong> Modify the program above so that it handles concurrent connections correctly.</p>
<h2 id="tcp-client-and-ownership">TCP client and ownership</h2>
<p>Let's write a poor man's HTTP client. It will establish a connection to a hard-coded server, copy all of <code>stdin</code> to the server, and then copy all data from the server to <code>stdout</code>. To use this, you'll manually type in the HTTP request and then hit <code>Ctrl-D</code> for end-of-file.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::net::TcpStream;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; io::</span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;()&gt; {
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> stream = TcpStream::connect(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">127.0.0.1:8080</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#268bd2;">let </span><span style="color:#657b83;">(</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> recv, </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> send) = io::split(stream);
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin = io::stdin();
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout = io::stdout();

    io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> send).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> recv, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;

    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>That's all well and good, but it's limited. It only handles half-duplex protocols like HTTP, and doesn't actually support keep-alive in any way. We'd like to use <code>spawn</code> to run the two <code>copy</code>s in different tasks. Seems easy enough:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#268bd2;">let</span><span style="color:#657b83;"> send = </span><span style="color:#859900;">spawn</span><span style="color:#657b83;">(io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> send));
</span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> recv = </span><span style="color:#859900;">spawn</span><span style="color:#657b83;">(io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> recv, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout));

send.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
recv.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
</span></code></pre>
<p>Unfortunately, this doesn't compile. We get four nearly-identical error messages. Let's look at the first:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">error[E0597]: `stdin` does not live long enough
  --&gt; src/main.rs:12:31
   |
12 |     let send = spawn(io::copy(&amp;mut stdin, &amp;mut send));
   |                      ---------^^^^^^^^^^------------
   |                      |        |
   |                      |        borrowed value does not live long enough
   |                      argument requires that `stdin` is borrowed for `&#39;static`
...
19 | }
   | - `stdin` dropped here while still borrowed
</span></code></pre>
<p>Here's the issue: our <code>copy</code> <code>Future</code> does not <em>own</em> the <code>stdin</code> value (or the <code>send</code> value, for that matter). Instead, it has a (mutable) reference to it. That value remains in the <code>main</code> function's <code>Future</code>. Ignoring error cases, we know that the <code>main</code> function will wait for <code>send</code> to complete (thanks to <code>send.await</code>), and therefore the lifetimes appear to be correct. However, Rust doesn't recognize this lifetime information. (Also, and I haven't thought this through completely, I'm fairly certain that <code>send</code> may be dropped earlier than the <code>Future</code> using it in the case of <code>panic</code>s.)</p>
<p>In order to fix this, we need to convince the compiler to make a <code>Future</code> that owns <code>stdin</code>. And the easiest way to do that here is to use an <code>async move</code> block.</p>
<p><strong>Exercise 7</strong> Make the code above compile using two <code>async move</code> blocks.</p>
<h2 id="playing-with-lines">Playing with <code>lines</code></h2>
<p>This section will have a series of modifications to a program. I recommend you solve each challenge before looking at the solution. However, unlike the other exercises, I'm going to show the solutions inline since they build on each other.</p>
<p>Let's build an async program that counts the number of lines on standard input. You'll want to use the <a href="https://docs.rs/tokio/0.2.2/tokio/io/trait.AsyncBufReadExt.html#method.lines"><code>lines</code></a> method for this. Read the docs and try to figure out what <code>use</code>s and wrappers will be necessary to make the types line up.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::prelude::*;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io::AsyncBufReadExt;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> stdin = io::stdin();
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> stdin = io::BufReader::new(stdin);
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> count = </span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">;
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> lines = stdin.</span><span style="color:#859900;">lines</span><span style="color:#657b83;">();
    </span><span style="color:#859900;">while </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span style="color:#859900;">_</span><span style="color:#657b83;">) = lines.</span><span style="color:#859900;">next_line</span><span style="color:#657b83;">().await</span><span style="color:#859900;">? </span><span style="color:#657b83;">{
        count += </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
    }
    </span><span style="color:#859900;">println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Lines on stdin: </span><span style="color:#cb4b16;">{}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, count);
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>OK, bumping this up one more level. Instead of standard input, let's take a list of file names as command line arguments, and count up the total number of lines in all the files. Initially, it's OK to read the files one at a time. In other words: don't bother calling <code>spawn</code>. Give it a shot, and then come back here:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::prelude::*;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io::AsyncBufReadExt;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> args = std::env::args();
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> _me = args.</span><span style="color:#859900;">next</span><span style="color:#657b83;">(); </span><span style="color:#93a1a1;">// ignore command name
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> count = </span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">;

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> filename </span><span style="color:#859900;">in</span><span style="color:#657b83;"> args {
        </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = tokio::fs::File::open(filename).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
        </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = io::BufReader::new(file);
        </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> lines = file.</span><span style="color:#859900;">lines</span><span style="color:#657b83;">();
        </span><span style="color:#859900;">while </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span style="color:#859900;">_</span><span style="color:#657b83;">) = lines.</span><span style="color:#859900;">next_line</span><span style="color:#657b83;">().await</span><span style="color:#859900;">? </span><span style="color:#657b83;">{
            count += </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
        }
    }

    </span><span style="color:#859900;">println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Total lines: </span><span style="color:#cb4b16;">{}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, count);
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>But now it's time to make this properly asynchronous, and process the files in separate <code>spawn</code>ed tasks. In order to make this work, we need to spawn all of the tasks, and then <code>.await</code> each of them. I used a <code>Vec</code> of <code>Future&lt;Output=Result&lt;u32, std::io::Error&gt;&gt;</code>s for this. Give it a shot!</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::prelude::*;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io::AsyncBufReadExt;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> args = std::env::args();
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> _me = args.</span><span style="color:#859900;">next</span><span style="color:#657b83;">(); </span><span style="color:#93a1a1;">// ignore command name
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> tasks = </span><span style="color:#859900;">vec!</span><span style="color:#657b83;">[];

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> filename </span><span style="color:#859900;">in</span><span style="color:#657b83;"> args {
        tasks.</span><span style="color:#859900;">push</span><span style="color:#657b83;">(tokio::spawn(async {
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = tokio::fs::File::open(filename).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = io::BufReader::new(file);
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> lines = file.</span><span style="color:#859900;">lines</span><span style="color:#657b83;">();
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> count = </span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">;
            </span><span style="color:#859900;">while </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span style="color:#859900;">_</span><span style="color:#657b83;">) = lines.</span><span style="color:#859900;">next_line</span><span style="color:#657b83;">().await</span><span style="color:#859900;">? </span><span style="color:#657b83;">{
                count += </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
            }
            </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(count) </span><span style="color:#859900;">as Result</span><span style="color:#657b83;">&lt;</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">, std::io::Error&gt;
        }));
    }

    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> count = </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> task </span><span style="color:#859900;">in</span><span style="color:#657b83;"> tasks {
        count += task.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
    }

    </span><span style="color:#859900;">println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Total lines: </span><span style="color:#cb4b16;">{}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, count);
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>And finally in this progression: let's change how we handle the <code>count</code>. Instead of <code>.await</code>ing the count in the second <code>for</code> loop, let's have each individual task update a shared mutable variable. You should use an <code>Arc&lt;Mutex&lt;u32&gt;&gt;</code> for that. You'll still need to keep a <code>Vec</code> of the tasks though to ensure you wait for all files to be read.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::prelude::*;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io::AsyncBufReadExt;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">std::sync::Arc;

</span><span style="color:#93a1a1;">// avoid thread blocking by using Tokio&#39;s mutex
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::sync::Mutex;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> args = std::env::args();
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> _me = args.</span><span style="color:#859900;">next</span><span style="color:#657b83;">(); </span><span style="color:#93a1a1;">// ignore command name
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> tasks = </span><span style="color:#859900;">vec!</span><span style="color:#657b83;">[];
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> count = Arc::new(Mutex::new(</span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">));

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> filename </span><span style="color:#859900;">in</span><span style="color:#657b83;"> args {
        </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> count = count.</span><span style="color:#859900;">clone</span><span style="color:#657b83;">();
        tasks.</span><span style="color:#859900;">push</span><span style="color:#657b83;">(tokio::spawn(async </span><span style="color:#586e75;">move </span><span style="color:#657b83;">{
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = tokio::fs::File::open(filename).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = io::BufReader::new(file);
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> lines = file.</span><span style="color:#859900;">lines</span><span style="color:#657b83;">();
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> local_count = </span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">;
            </span><span style="color:#859900;">while </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span style="color:#859900;">_</span><span style="color:#657b83;">) = lines.</span><span style="color:#859900;">next_line</span><span style="color:#657b83;">().await</span><span style="color:#859900;">? </span><span style="color:#657b83;">{
                local_count += </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
            }

            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> count = count.</span><span style="color:#859900;">lock</span><span style="color:#657b83;">().await;
            *count += local_count;
            </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(()) </span><span style="color:#859900;">as Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt;
        }));
    }

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> task </span><span style="color:#859900;">in</span><span style="color:#657b83;"> tasks {
        task.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
    }

    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> count = count.</span><span style="color:#859900;">lock</span><span style="color:#657b83;">().await;
    </span><span style="color:#859900;">println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Total lines: </span><span style="color:#cb4b16;">{}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, *count);
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre><h2 id="localset-and-send">LocalSet and <code>!Send</code></h2>
<p>Thanks to <a href="https://twitter.com/xudesheng/status/1201382514415325185?s=20">@xudehseng</a> for the inspiration on this section.</p>
<p>OK, did that last exercise seem a bit contrived? It was! In my opinion, the previous approach of <code>.await</code>ing the counts and summing in the <code>main</code> function itself was superior. However, I wanted to teach you something else.</p>
<p>What happens if you replace the <code>Arc&lt;Mutex&lt;u32&gt;&gt;</code> with a <code>Rc&lt;RefCell&lt;u32&gt;&gt;</code>? With this code:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::prelude::*;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io::AsyncBufReadExt;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">std::rc::Rc;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">std::cell::RefCell;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> args = std::env::args();
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> _me = args.</span><span style="color:#859900;">next</span><span style="color:#657b83;">(); </span><span style="color:#93a1a1;">// ignore command name
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> tasks = </span><span style="color:#859900;">vec!</span><span style="color:#657b83;">[];
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> count = Rc::new(RefCell::new(</span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">));

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> filename </span><span style="color:#859900;">in</span><span style="color:#657b83;"> args {
        </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> count = count.</span><span style="color:#859900;">clone</span><span style="color:#657b83;">();
        tasks.</span><span style="color:#859900;">push</span><span style="color:#657b83;">(tokio::spawn(async {
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = tokio::fs::File::open(filename).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = io::BufReader::new(file);
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> lines = file.</span><span style="color:#859900;">lines</span><span style="color:#657b83;">();
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> local_count = </span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">;
            </span><span style="color:#859900;">while </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span style="color:#859900;">_</span><span style="color:#657b83;">) = lines.</span><span style="color:#859900;">next_line</span><span style="color:#657b83;">().await</span><span style="color:#859900;">? </span><span style="color:#657b83;">{
                local_count += </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
            }

            *count.</span><span style="color:#859900;">borrow_mut</span><span style="color:#657b83;">() += local_count;
            </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(()) </span><span style="color:#859900;">as Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt;
        }));
    }

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> task </span><span style="color:#859900;">in</span><span style="color:#657b83;"> tasks {
        task.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
    }

    </span><span style="color:#859900;">println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Total lines: </span><span style="color:#cb4b16;">{}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, count.</span><span style="color:#859900;">borrow</span><span style="color:#657b83;">());
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>
<p>You get an error:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">error[E0277]: `std::rc::Rc&lt;std::cell::RefCell&lt;u32&gt;&gt;` cannot be shared between threads safely
  --&gt; src/main.rs:15:20
   |
15 |         tasks.push(tokio::spawn(async {
   |                    ^^^^^^^^^^^^ `std::rc::Rc&lt;std::cell::RefCell&lt;u32&gt;&gt;` cannot be shared between threads safely
   |
  ::: /Users/michael/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-0.2.2/src/task/spawn.rs:49:17
   |
49 |     T: Future + Send + &#39;static,
   |                 ---- required by this bound in `tokio::task::spawn::spawn`
</span></code></pre>
<p>Tasks can be scheduled to multiple different threads. Therefore, your <code>Future</code> must be <code>Send</code>. And <code>Rc&lt;RefCell&lt;u32&gt;&gt;</code> is definitely <code>!Send</code>. However, in our use case, using multiple OS threads is unlikely to speed up our program; we're going to be doing lots of blocking I/O. It would be nice if we could insist on spawning all our tasks on the same OS thread and avoid the need for <code>Send</code>. And sure enough, Tokio provides such a function: <code>tokio::task::spawn_local</code>. Using it (and adding back in <code>async move</code> instead of <code>async</code>), our program compiles, but breaks at runtime:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">thread &#39;main&#39; panicked at &#39;`spawn_local` called from outside of a local::LocalSet!&#39;, src/libcore/option.rs:1190:5
</span></code></pre>
<p>Uh-oh! Now I'm personally not a big fan of this detect-it-at-runtime stuff, but the concept is simple enough: if you want to spawn onto the current thread, you need to set up your runtime to support that. And the way we do that is with <a href="https://docs.rs/tokio/0.2.2/tokio/task/struct.LocalSet.html"><code>LocalSet</code></a>. In order to use this, you'll need to ditch the <code>#[tokio::main]</code> attribute.</p>
<p><strong>EXERCISE 8</strong> Follow the documentation for <code>LocalSet</code> to make the program above work with <code>Rc&lt;RefCell&lt;u32&gt;&gt;</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That lesson felt short. Definitely compared to the previous Tokio lesson which seemed to go on forever. I think this is a testament to how easy to use the new <code>async/</code>.await` syntax is.</p>
<p>There's obviously a lot more that can be covered in asynchronous programming, but hopefully this establishes the largest foundations you need to understand to work with the <code>async</code>/<code>.await</code> syntax and the Tokio library itself.</p>
<p>If we have future lessons, I believe they'll cover additional libraries like Hyper as they move over to Tokio 0.2, as well as specific use cases people raise. If you want something covered, mention it to me on Twitter or in the comments below.</p>
<h2 id="solutions">Solutions</h2>
<h3 id="solution-1">Solution 1</h3>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin = io::stdin();
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout = io::stdout();
    io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre><h3 id="solution-2">Solution 2</h3>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::process::Command;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#859900;">for _ in </span><span style="color:#6c71c4;">1</span><span style="color:#859900;">..</span><span style="color:#657b83;">=</span><span style="color:#6c71c4;">10 </span><span style="color:#657b83;">{
        Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">echo</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">arg</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Hello, world!</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    }
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre><h3 id="solution-3">Solution 3</h3>
<p>Since the <code>loop</code> will either run forever or be short circuited by an error, any code following <code>loop</code> will never actually be called. Therefore, code placed there will generate a warning.</p>
<h3 id="solution-4">Solution 4</h3>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">std::time::Duration;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::process::Command;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::{io, task, time};

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> dating = task::spawn(</span><span style="color:#859900;">dating</span><span style="color:#657b83;">());
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> copying = task::spawn(</span><span style="color:#859900;">copying</span><span style="color:#657b83;">());

    dating.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
    copying.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;

    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}

async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">dating</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> interval = time::interval(Duration::from_secs(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">));
    </span><span style="color:#859900;">loop </span><span style="color:#657b83;">{
        interval.</span><span style="color:#859900;">tick</span><span style="color:#657b83;">().await;
        Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">date</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    }
}

async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">copying</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin = io::stdin();
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout = io::stdout();
    io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre><h3 id="solution-5">Solution 5</h3>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">dating</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#859900;">loop </span><span style="color:#657b83;">{
        task::spawn_blocking(|| { std::thread::sleep(Duration::from_secs(</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)) }).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
        Command::new(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">date</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).</span><span style="color:#859900;">spawn</span><span style="color:#657b83;">()</span><span style="color:#859900;">?</span><span style="color:#657b83;">.await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    }
}
</span></code></pre><h3 id="solution-6">Solution 6</h3>
<p>The simplest tweak is to wrap the <code>echo</code> call with <code>tokio::spawn</code>:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">loop </span><span style="color:#657b83;">{
    </span><span style="color:#268bd2;">let </span><span style="color:#657b83;">(socket, </span><span style="color:#859900;">_</span><span style="color:#657b83;">) = listener.</span><span style="color:#859900;">accept</span><span style="color:#657b83;">().await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    tokio::spawn(</span><span style="color:#859900;">echo</span><span style="color:#657b83;">(socket));
}
</span></code></pre>
<p>There is a downside to this worth noting, however: we're ignoring the errors produced by the spawned tasks. Likely the best behavior in this case is to handle the errors inside the spawned task:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; io::</span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;()&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> listener = TcpListener::bind(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">127.0.0.1:8080</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;

    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> counter = </span><span style="color:#6c71c4;">1</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">;
    </span><span style="color:#859900;">loop </span><span style="color:#657b83;">{
        </span><span style="color:#268bd2;">let </span><span style="color:#657b83;">(socket, </span><span style="color:#859900;">_</span><span style="color:#657b83;">) = listener.</span><span style="color:#859900;">accept</span><span style="color:#657b83;">().await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
        </span><span style="color:#859900;">println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Accepted connection #</span><span style="color:#cb4b16;">{}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, counter);
        tokio::spawn(async </span><span style="color:#586e75;">move </span><span style="color:#657b83;">{
            </span><span style="color:#859900;">match echo</span><span style="color:#657b83;">(socket).await {
                </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(()) </span><span style="color:#859900;">=&gt; println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Connection #</span><span style="color:#cb4b16;">{}</span><span style="color:#2aa198;"> completed successfully</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, counter),
                </span><span style="color:#859900;">Err</span><span style="color:#657b83;">(e) </span><span style="color:#859900;">=&gt; println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Connection #</span><span style="color:#cb4b16;">{}</span><span style="color:#2aa198;"> errored: </span><span style="color:#cb4b16;">{:?}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, counter, e),
            }
        });
        counter += </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
    }
}
</span></code></pre><h3 id="exericse-7">Exericse 7</h3>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::spawn;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::net::TcpStream;

#[</span><span style="color:#268bd2;">tokio</span><span style="color:#657b83;">::</span><span style="color:#268bd2;">main</span><span style="color:#657b83;">]
async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; io::</span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;()&gt; {
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> stream = TcpStream::connect(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">127.0.0.1:8080</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#268bd2;">let </span><span style="color:#657b83;">(</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> recv, </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> send) = io::split(stream);
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin = io::stdin();
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout = io::stdout();

    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> send = </span><span style="color:#859900;">spawn</span><span style="color:#657b83;">(async </span><span style="color:#586e75;">move </span><span style="color:#657b83;">{
        io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdin, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> send).await
    });
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> recv = </span><span style="color:#859900;">spawn</span><span style="color:#657b83;">(async </span><span style="color:#586e75;">move </span><span style="color:#657b83;">{
        io::copy(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> recv, </span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> stdout).await
    });

    send.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
    recv.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;

    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre><h2 id="solution-8">Solution 8</h2>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::prelude::*;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">tokio::io::AsyncBufReadExt;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">std::rc::Rc;
</span><span style="color:#859900;">use </span><span style="color:#657b83;">std::cell::RefCell;

</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> rt = tokio::runtime::Runtime::new()</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> local = tokio::task::LocalSet::new();
    local.</span><span style="color:#859900;">block_on</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> rt, </span><span style="color:#859900;">main_inner</span><span style="color:#657b83;">())
}

async </span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">main_inner</span><span style="color:#657b83;">() -&gt; </span><span style="color:#859900;">Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt; {
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> args = std::env::args();
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> _me = args.</span><span style="color:#859900;">next</span><span style="color:#657b83;">(); </span><span style="color:#93a1a1;">// ignore command name
    </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> tasks = </span><span style="color:#859900;">vec!</span><span style="color:#657b83;">[];
    </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> count = Rc::new(RefCell::new(</span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">));

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> filename </span><span style="color:#859900;">in</span><span style="color:#657b83;"> args {
        </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> count = count.</span><span style="color:#859900;">clone</span><span style="color:#657b83;">();
        tasks.</span><span style="color:#859900;">push</span><span style="color:#657b83;">(tokio::task::spawn_local(async </span><span style="color:#586e75;">move </span><span style="color:#657b83;">{
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = tokio::fs::File::open(filename).await</span><span style="color:#859900;">?</span><span style="color:#657b83;">;
            </span><span style="color:#268bd2;">let</span><span style="color:#657b83;"> file = io::BufReader::new(file);
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> lines = file.</span><span style="color:#859900;">lines</span><span style="color:#657b83;">();
            </span><span style="color:#268bd2;">let </span><span style="color:#586e75;">mut</span><span style="color:#657b83;"> local_count = </span><span style="color:#6c71c4;">0</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">;
            </span><span style="color:#859900;">while </span><span style="color:#268bd2;">let </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span style="color:#859900;">_</span><span style="color:#657b83;">) = lines.</span><span style="color:#859900;">next_line</span><span style="color:#657b83;">().await</span><span style="color:#859900;">? </span><span style="color:#657b83;">{
                local_count += </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">;
            }

            *count.</span><span style="color:#859900;">borrow_mut</span><span style="color:#657b83;">() += local_count;
            </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(()) </span><span style="color:#859900;">as Result</span><span style="color:#657b83;">&lt;(), std::io::Error&gt;
        }));
    }

    </span><span style="color:#859900;">for</span><span style="color:#657b83;"> task </span><span style="color:#859900;">in</span><span style="color:#657b83;"> tasks {
        task.await</span><span style="color:#859900;">??</span><span style="color:#657b83;">;
    }

    </span><span style="color:#859900;">println!</span><span style="color:#657b83;">(</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Total lines: </span><span style="color:#cb4b16;">{}</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">, count.</span><span style="color:#859900;">borrow</span><span style="color:#657b83;">());
    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
}
</span></code></pre>

<div class="text-center"><a href="/blog/" class="btn btn-primary">Read more blog posts</a></div>

      <div id="disqus_thread"></div>
      <script>
        (function() {var d = document, s = d.createElement('script'); s.src = '//snoyberg.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s);})();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<!--
    </div>

    <div class="col-lg-3" id="archive">
      <h3>Blog archive</h3>
      <ul class="blog-archive">
            $forall ((year, month, slug), post) <- posts
                <li>
                    <a href=@?{addPreview $ PostR year month slug}>#{postTitle post}
                    \ #
                    <i>#{prettyDay now (postTime post)}
-->

<div class="text-center"><a href="/blog/" class="btn btn-primary">Read more blog posts</a></div>


            </div>
          </div>
        </div>
      </section>
    </main>

    
<footer class="bg-dark py-5">
  <ul class="list-inline text-center text-md-right mb-0">
    <li class="list-inline-item mx-2">
      <a href="https://twitter.com/snoyberg">Follow @snoyberg</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://twitter.com/intent/tweet?screen_name=snoyberg">Tweet to @snoyberg</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://github.com/snoyberg">Github</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://tech.fpcomplete.com/">FP Complete</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://www.haskellers.com/user/snoyberg">I'm a Haskeller</a>
    </li>
  </ul>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1434510-21', 'auto');
  ga('send', 'pageview');
</script>

<!-- JS Script Files -->
<!-- Global Vendor -->
<script src="/maxi/vendors/jquery.min.js"></script>
<script src="/maxi/vendors/jquery.migrate.min.js"></script>
<script src="/maxi/vendors/popper.min.js"></script>
<script src="/maxi/vendors/bootstrap/js/bootstrap.min.js"></script>

<!-- Components Vendor  --> 
<script src="/maxi/contact/jqBootstrapValidation.js"></script>
<!--Plugin Initialize-->
<script src="/maxi/js/global.js"></script>
<!-- END JAVASCRIPTS -->


  </body>
</html>
