
    

<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <title>Stackage design choices: making Haskell curated package sets</title>

    <meta name="twitter:site" content="@snoyberg">
    <meta name="twitter:creator" content="@snoyberg">
    <meta name="og:site_name" content="Michael Snoyman's homepage">
    <meta name="og:title" content="Stackage design choices: making Haskell curated package sets">
    <meta name="og:type content="website">

    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"> 
    <link rel="stylesheet" href="/maxi/vendors/font-awesome/css/fontawesome-all.min.css">
    <link rel="stylesheet" type="text/css" href="/maxi/css/styles.css">

    






    <link rel="openid2.provider" href="https://openid.stackexchange.com/openid/provider">
    <link rel="openid2.local_id" href="https://openid.stackexchange.com/user/d26546d2-46db-4099-83ca-e1eccfa0dd8d">
    <link href="/rss.xml" type="application/atom+xml" rel="alternate" title="Michael Snoyman's blog">

    <style>.wt-section { padding-top: 2rem }</style>
  <body>
    <header class="inner-page">
      

<nav class="js-navbar-scroll navbar fixed-top navbar-expand-lg">
  <div class="container-fluid">
    <a class="navbar-brand" href="/">
      <img src="/img/snoylogo.png" height="50px">
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo" aria-controls="navbarTogglerDemo" aria-expanded="false" aria-label="Toggle navigation">
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse onCollapse" id="navbarTogglerDemo">
      <ul class="navbar-nav ml-auto mt-2 mt-lg-0">
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="/blog">Blog</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.yesodweb.com/">Yesod</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="http://shop.oreilly.com/product/0636920035664.do">Yesod Book</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.beginrust.com/">Rust Book</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.youtube.com/c/snoyberg">YouTube</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://twitter.com/snoyberg">Twitter</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://github.com/snoyberg">Github</a>
        </li>
      </ul>
    </div>
  </div>
</nav>



      <section class="wt-section bg-gray text-center inner-page-header" style="padding-top:100px">
        <div class="container">
          <div class="row justify-content-md-center align-items-center text-white py-lg-5">
            <div class="col-md-7">
              <div class="text-center">
                <h1 class="display-sm-4 display-lg-3">Stackage design choices: making Haskell curated package sets</h1>
                
<p class="h6 text-uppercase wt-letter-spacing-sm mb-0">Published January 23, 2017</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </header>

    <main role="main">
      <section class="wt-section">
        <div class="container">
          <div class="row justify-content-between">
            <div class="col-lg-12">
              <p class="text-center">
                <a class="btn" style="background: #72472f; color: #fff; font-weight: bold" href="https://www.beginrust.com/">New: The "Begin Rust" book</a>
              </p>

              




  


<div class="share-bar-wrapper">
  <div class="share-bar-inner">
    <b>Share this</b>
    <a target="_blank" href="https://twitter.com/intent/tweet?text=Stackage%20design%20choices%3A%20making%20Haskell%20curated%20package%20sets https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;01&#x2F;stackage-design-choices&#x2F;" title="Share on Twitter">
      <i class="fab fa-twitter"></i>
    </a>

    <a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;01&#x2F;stackage-design-choices&#x2F;" title="Share on Facebook">
      <i class="fab fa-facebook"></i>
    </a>

    <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;01&#x2F;stackage-design-choices&#x2F;&amp;title=Stackage%20design%20choices%3A%20making%20Haskell%20curated%20package%20sets" title="Share on LinkedIn">
      <i class="fab fa-linkedin"></i>
    </a>

    <a target="_blank" href="https://www.reddit.com/submit?url=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;01&#x2F;stackage-design-choices&#x2F;" title="Share on Reddit">
      <i class="fab fa-reddit"></i>
    </a>
  </div>
</div>



<!--
<div class="container" id="blog-body">
  <div class="row">
    <div class="col-lg-9">
-->
      <p>
        <i>
          See a typo? Have a suggestion?
          <a target="_blank" rel="nofollow" href="https://github.com/snoyberg/snoyman.com/edit/master/content/blog&#x2F;stackage-design-choices.md">Edit this page on Github</a>
        </i>
      </p>

      <p>This post is going to talk about some of the design choices made over
the years around the
<a href="https://github.com/fpco/stackage#readme">Stackage project</a>, a curated
package set for Haskell. While many of these points will be Haskell-
and Stackage-specific, I think the ideas would translate well to other
languages interested in created curated package sets. This blog post
was inspired by a short discussion on Twitter, which made it clear
that I'd never really shared design thoughts on the Stackage project:</p>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/snoyberg">@snoyberg</a> <a href="https://twitter.com/iElectric">@iElectric</a> sounds like you&#39;ve put already a lot of thought into that. would luv to learn more about!</p>&mdash; Haskell Dev (@haskdev) <a href="https://twitter.com/haskdev/status/821085009763246081">January 16, 2017</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>In understanding why Stackage is the way it is today, it will be
important to take into account:</p>
<ul>
<li>The goals of the project</li>
<li>The historical circumstances when decisions were made</li>
<li>Social pressures in the community agitating for specific decisions</li>
<li>Inertia in the project making significant changes difficult</li>
</ul>
<p>Apologies in advance, this turned out longer than I'd intended.</p>
<h2 id="goals">Goals</h2>
<p>Before Stackage, the most common way to find a set of libraries to use
in a Haskell project was using cabal-install's dependency solver,
based on bounds information specified by authors. There were certainly
some efforts at creating curated package sets previously (Haskell
Platform provided a limited set; the Yesod Platform provided a full
set of packages for the Yesod Web Framework; various Linux distros had
binary packages). But I think it's fair to say that the vast majority
of people writing Haskell code were using dependency solving.</p>
<p>I'm not going to get into the argument of dependency solving vs
curation here. I will simply say that for many people - myself
included - having official combinations of packages which are known to
compile together, and which can be given to end users and teammates on
a project, was very appealing. This was the motivation for my
<a href="http://www.yesodweb.com/blog/2012/11/stable-vetted-hackage">initial Stackage call for participation</a>.</p>
<p>While the primary goal - create curated package sets - is obvious, the
secondary goals are not. In fact, many of them only really became
clear to me in 20-20 hindsight:</p>
<ul>
<li>
<p>Require as little maintenance as possible. Stackage should be as
much an automated process as can be created, since human time is a
valuable, scarce resource. In other words: I'm lazy :).</p>
</li>
<li>
<p>Require as little change in behavior from package authors as
possible. In my opinion, the only reasonable way to bootstrap a
project is to make it trivial for people to participate. The barrier
to entry for Stackage had to be minimal.</p>
<ul>
<li>Even past the &quot;bootstrapping&quot; phase, a nice quality of <em>any</em>
system is requiring little effort on the part of
users. Therefore, even today, where Stackage is arguably
successful and well-established, this goal still applies.</li>
</ul>
</li>
<li>
<p>It needed to work well with existing tooling. In 2012, the Stack
project hadn't even been dreamt up yet, so figuring out a way to
work with cabal-install (via the cabal.config file) was
vital. Compatibility with cabal-install is still a nice thing today,
but not nearly as vital as it was then.</p>
</li>
<li>
<p>We need to maximize the number of packages that can be included in
a single snapshot. The two ways in which two packages can be
incompatible are:</p>
<ul>
<li>
<p>There is an actual incompatibility in the API, such as a
function being removed or its type signature changed in a new
release of a dependency.</p>
</li>
<li>
<p>There is a stated upper or lower bound in a package which
precludes a build plan, but the code itself would actually
compile. (This is the case <code>--allow-newer</code> is designed for.)</p>
</li>
</ul>
</li>
</ul>
<h3 id="initial-choices">Initial choices</h3>
<p>Based on these goals, I created the initial version of Stackage. While
many decisions came into play (e.g., what file format should we use to
let package authors submit packages?), I'm going to focus on the
interesting choices that fell out of the goals above, and which today
may be noteworthy.</p>
<ul>
<li>
<p>As I'd learnt from maintaining Yesod, many Windows users in
particular were using the Haskell Platform (HP), and trying to
specify different versions of packages from what HP provided could
cause problems. Therefore, it was important to keep compatibility
with the Haskell Platform set of packages. This resulted in multiple
builds of Stackage: a &quot;current GHC&quot;, &quot;previous GHC&quot;, and &quot;Haskell
Platform superset.&quot;</p>
</li>
<li>
<p>We should always try to take the latest available version of a
package, as it may include bug fixes, feature enhancements, and
generally because the Haskell community loves the bleeding edge
:). However, there would be cases where a new version of a package
caused enough breakage to warrant holding it back, so some concept
of enforced upper bounds was necessary too.</p>
</li>
<li>
<p>It was theoretically possible to ignore version bound information
in cabal files, and instead ensure compatibility based on
compiling and running test suites. However, this would have some
serious downsides:</p>
<ul>
<li>Users would have regularly needed to run builds with
<code>--allow-newer</code></li>
<li>If there were non-API-breaking semantic changes in a package, a
version bound was present to avoid those changes, and there was
no test suite to cover that behavior, ignoring bounds would
cause those semantic changes to slip in (in my experience, this
is an exceedingly rare case, but it can happen)</li>
<li>It's arguably very confusing behavior that a package set
specifies versions of packages which claim to be incompatible
with each other</li>
</ul>
<p>Therefore, version bounds needed to be respected. However...</p>
</li>
<li>
<p>Due to the frequency of overly restrictive version bounds and
trivial compatibility patches which were slow to make it upstream,
Stackage allowed for locally modified packages. That means that, for
example, Stackage snapshot <code>foo</code> could have a different set of code
associated with <code>mtl-2.2.1</code> than what Hackage reports. Note that
this feature was more aggressive than Hackage cabal file revisions,
in that it allowed the code itself to change, not just the cabal
file.</p>
</li>
</ul>
<p>These decisions lasted for (IIRC) about a year, and were overall
successful at letting Stackage become a thriving project. I was soon
able to <a href="http://www.yesodweb.com/blog/2014/08/deprecating-yesod-platform">shut down the Yesod Platform initiative</a>
in favor of Stackage,
which was a huge relief for me. At this point, outside of the Yesod
community, I think Stackage was viewed mostly as a &quot;ecosystem-wide CI
system&quot; than something for end users. It wasn't until Stack defaulted
to Stackage snapshots that end users en masse started using Stackage.</p>
<h2 id="changes-over-time">Changes over time</h2>
<p>Stackage today is quite a bit different from the above decisions:</p>
<ul>
<li>
<p>I eventually dropped the Haskell Platform superset. There was a
time when that package set wasn't updated, and the complication of
trying to find a compatible set of packages on top of it was simply
too high. In addition, HP included a version of aeson with a
significant security hole (DoS attack with small inputs), and
continuing to supply such a package set was not something I felt
comfortable doing.</p>
</li>
<li>
<p>Due to the burden of maintaining bleeding-edge Stackages for
multiple GHC versions - both on myself as the curator and on package
authors - I also dropped support for older GHC releases. Instead, I
introduced LTS Haskell, which keeps compatibility with older GHCs
without adding (significant) package author burden.</p>
</li>
<li>
<p>When working on the GPS Haskell collaboration, I removed support for
locally modified packages. This was done due to requests from the
Hackage and Haskell Platform maintainers, who wanted a single
definition of a package. With this change, unresponsive package
maintainers can really hold things up in Stackage. However, this
overall led to a number of simplifications in code, and ultimately
allowed for better binary cache support in Stack. So despite the
initial pain, I think this was a good change.</p>
</li>
<li>
<p>Hackage revisions make it possible for a package set to contain
packages which are no longer compatible by their latest cabal
files. Therefore, we needed to add support to Stackage to track
which version of a cabal file was included in a snapshot, not just
the version of the package itself. I only mention this here because
it weakens our previous decision to respect cabal file constraints
due to avoiding user confusion.</p>
</li>
<li>
<p>We have an expanded team! I'm happy to say that I am now one of five
Stackage curators, and no longer have to either handle all the work
myself, or make unilateral decisions. In other words, I get to share
the blame with others :). Many thanks to Adam Bergmark, Dan Burton,
Jens Petersen, and our newest member, Luke Murphy.</p>
</li>
</ul>
<h2 id="changes-to-consider-today">Changes to consider today</h2>
<p>Alright, this post has turned out way longer than I'd expected,
apologies for this. I guess there was more decision making that
occurred than I'd realized. Anyway, I hope that gives some context for
where things are at today. Which brings us to the original discussion
that brought this whole blog post into existence: should we be
changing anything about Stackage? Here are some changes either
proposed by others or that I've thought of, and some remarks.</p>
<ul>
<li>
<p>The curator team overall has been pretty lax about booting packages
that block newer versions of dependencies. There have definitely
been calls for us to be more proactive about that, and aggressively
kick out packages that are holding back dependencies.</p>
<ul>
<li>
<p>Pros: Stackage Nightly will live up to its bleeding edge mission
statement more effectively, we'll overall have less incidental
pain on package authors who are staying up to date with their
dependencies.</p>
</li>
<li>
<p>Cons: it will decrease the number of packages in Stackage
Nightly for end users, and adds extra burden on package authors
to be more quick to respond to requests.</p>
</li>
</ul>
</li>
<li>
<p>As a relaxed version of the above: be stricter with package authors,
but only in the case of cabal file upper bounds. The argument here
is stronger, since the work required is fairly minimal, and - at
least in my experience - waiting for relaxed upper bounds is what
takes up a lot of the time when curating. An extreme version of this
is demanding that
<a href="https://twitter.com/haskdev/status/820932892385808384">upper bounds just be removed</a>.</p>
</li>
<li>
<p>Or an interesting alternative to that: should Stackage simply ignore
constraints in cabal files entirely? It would be fairly easy to
extend Stack to recognize a flag in snapshots to say &quot;ignore the
constraints when building,&quot; or even make that the default behavior.</p>
<ul>
<li>
<p>Pros: less time spent on bounds issues, Stackage doesn't get
held back by trivial version bounds issues, for PVP bounds
enthusiasts could encourage people to add bounds during upload
more often (not sure of that).</p>
</li>
<li>
<p>Cons: cabal users with Stackage snapshots wouldn't have as nice
a time, it could be confusing for users, and if the upper bounds
are in place due to semantic changes we won't catch it.</p>
</li>
</ul>
</li>
<li>
<p>Since GPS Haskell isn't happening, we could add back the ability for
the Stackage curator team to modify packages (both cabal files and
source files). I think the pros and cons of this were pretty well
established above, I'm not going to repeat it here.</p>
</li>
<li>
<p>People have asked for running multiple nightly lines with different
GHC versions.</p>
<ul>
<li>
<p>Pros: instead of haven't slightly outdated LTS versions for
older GHCs, we'd have bleeding edge all over again.</p>
</li>
<li>
<p>Cons: we'd need new naming schemes for snapshots, a lot more
work for the curator team, and potentially a lot more work for
package authors who would need to maintain further GHC
compatibility with their most recent releases.</p>
</li>
</ul>
</li>
<li>
<p>I've had some private discussions around this, and thought I should share the
idea here. Right now, Stackage requires that any package added must be
available on Hackage. A number of newer build systems have been going the route
of allowing packages to be present only in a Git repository. Stack has built-in
support for specifying such locations, but snapshots do not support it. Should
we add support to Stackage to allow packages to be pulled from places besides
Hackage?</p>
<ul>
<li>
<p>Pros: knocks down another barrier to entry for publishing packages.</p>
</li>
<li>
<p>Cons: Stackage snapshots will not automatically work with cabal-install
anymore, extra work to be done to make this functional, and some issues
around determining who owns a package name need to be worked out.</p>
</li>
</ul>
</li>
</ul>
<p>There are likely other changes that I haven't mentioned, feel free to
raise them in the comments below. Also, if anyone really wants to
follow up on these topics, the best place to do that is
<a href="https://groups.google.com/d/forum/stackage">the Stackage mailing list</a>.</p>


<div class="text-center"><a href="/blog/" class="btn btn-primary">Read more blog posts</a></div>

      <div id="disqus_thread"></div>
      <script>
        (function() {var d = document, s = d.createElement('script'); s.src = '//snoyberg.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s);})();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<!--
    </div>

    <div class="col-lg-3" id="archive">
      <h3>Blog archive</h3>
      <ul class="blog-archive">
            $forall ((year, month, slug), post) <- posts
                <li>
                    <a href=@?{addPreview $ PostR year month slug}>#{postTitle post}
                    \ #
                    <i>#{prettyDay now (postTime post)}
-->

<div class="text-center"><a href="/blog/" class="btn btn-primary">Read more blog posts</a></div>


            </div>
          </div>
        </div>
      </section>
    </main>

    
<footer class="bg-dark py-5">
  <ul class="list-inline text-center text-md-right mb-0">
    <li class="list-inline-item mx-2">
      <a href="https://twitter.com/snoyberg">Follow @snoyberg</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://twitter.com/intent/tweet?screen_name=snoyberg">Tweet to @snoyberg</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://github.com/snoyberg">Github</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://tech.fpcomplete.com/">FP Complete</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://www.haskellers.com/user/snoyberg">I'm a Haskeller</a>
    </li>
  </ul>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1434510-21', 'auto');
  ga('send', 'pageview');
</script>

<!-- JS Script Files -->
<!-- Global Vendor -->
<script src="/maxi/vendors/jquery.min.js"></script>
<script src="/maxi/vendors/jquery.migrate.min.js"></script>
<script src="/maxi/vendors/popper.min.js"></script>
<script src="/maxi/vendors/bootstrap/js/bootstrap.min.js"></script>

<!-- Components Vendor  --> 
<script src="/maxi/contact/jqBootstrapValidation.js"></script>
<!--Plugin Initialize-->
<script src="/maxi/js/global.js"></script>
<!-- END JAVASCRIPTS -->


  </body>
</html>
