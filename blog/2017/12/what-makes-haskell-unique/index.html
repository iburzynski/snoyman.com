
    

<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <title>What Makes Haskell Unique</title>

    <meta name="twitter:site" content="@snoyberg">
    <meta name="twitter:creator" content="@snoyberg">
    <meta name="og:site_name" content="Michael Snoyman's homepage">
    <meta name="og:title" content="What Makes Haskell Unique">
    <meta name="og:type content="website">

    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"> 
    <link rel="stylesheet" href="/maxi/vendors/font-awesome/css/fontawesome-all.min.css">
    <link rel="stylesheet" type="text/css" href="/maxi/css/styles.css">

    

<meta name="og:description" value="A talk I gave at F(by) 2017 on what makes Haskell different from other languages">






    <link rel="openid2.provider" href="https://openid.stackexchange.com/openid/provider">
    <link rel="openid2.local_id" href="https://openid.stackexchange.com/user/d26546d2-46db-4099-83ca-e1eccfa0dd8d">
    <link href="/rss.xml" type="application/atom+xml" rel="alternate" title="Michael Snoyman's blog">

    <style>.wt-section { padding-top: 2rem }</style>
  <body>
    <header class="inner-page">
      

<nav class="js-navbar-scroll navbar fixed-top navbar-expand-lg">
  <div class="container-fluid">
    <a class="navbar-brand" href="/">
      <img src="/img/snoylogo.png" height="50px">
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo" aria-controls="navbarTogglerDemo" aria-expanded="false" aria-label="Toggle navigation">
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse onCollapse" id="navbarTogglerDemo">
      <ul class="navbar-nav ml-auto mt-2 mt-lg-0">
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="/blog">Blog</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.yesodweb.com/">Yesod</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="http://shop.oreilly.com/product/0636920035664.do">Yesod Book</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.beginrust.com/">Rust Book</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://www.youtube.com/c/snoyberg">YouTube</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://twitter.com/snoyberg">Twitter</a>
        </li>
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a class="nav-link" href="https://github.com/snoyberg">Github</a>
        </li>
      </ul>
    </div>
  </div>
</nav>



      <section class="wt-section bg-gray text-center inner-page-header" style="padding-top:100px">
        <div class="container">
          <div class="row justify-content-md-center align-items-center text-white py-lg-5">
            <div class="col-md-7">
              <div class="text-center">
                <h1 class="display-sm-4 display-lg-3">What Makes Haskell Unique</h1>
                
<p class="h6 text-uppercase wt-letter-spacing-sm mb-0">Published December 17, 2017</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </header>

    <main role="main">
      <section class="wt-section">
        <div class="container">
          <div class="row justify-content-between">
            <div class="col-lg-12">
              <p class="text-center">
                <a class="btn" style="background: #72472f; color: #fff; font-weight: bold" href="https://www.beginrust.com/">New: The "Begin Rust" book</a>
              </p>

              




  


<div class="share-bar-wrapper">
  <div class="share-bar-inner">
    <b>Share this</b>
    <a target="_blank" href="https://twitter.com/intent/tweet?text=What%20Makes%20Haskell%20Unique https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;12&#x2F;what-makes-haskell-unique&#x2F;" title="Share on Twitter">
      <i class="fab fa-twitter"></i>
    </a>

    <a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;12&#x2F;what-makes-haskell-unique&#x2F;" title="Share on Facebook">
      <i class="fab fa-facebook"></i>
    </a>

    <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;12&#x2F;what-makes-haskell-unique&#x2F;&amp;title=What%20Makes%20Haskell%20Unique" title="Share on LinkedIn">
      <i class="fab fa-linkedin"></i>
    </a>

    <a target="_blank" href="https://www.reddit.com/submit?url=https%3A&#x2F;&#x2F;www.snoyman.com&#x2F;blog&#x2F;2017&#x2F;12&#x2F;what-makes-haskell-unique&#x2F;" title="Share on Reddit">
      <i class="fab fa-reddit"></i>
    </a>
  </div>
</div>



<!--
<div class="container" id="blog-body">
  <div class="row">
    <div class="col-lg-9">
-->
      <p>
        <i>
          See a typo? Have a suggestion?
          <a target="_blank" rel="nofollow" href="https://github.com/snoyberg/snoyman.com/edit/master/content/blog&#x2F;what-makes-haskell-unique.md">Edit this page on Github</a>
        </i>
      </p>

      <p>I gave a talk today at the <a href="https://fby.by/">F(by) 2017 conference</a> in
Minsk, Belarus. The conference was great, I would definitely recommend
it in the future. Thank you very much to the organizers for the
opportunity to present on Haskell.</p>
<p>I prepared for this talk differently than I've prepared for other
talks in the past. I'm very comfortable writing up blog posts, but
have always found slide preparation difficult. This time around, I
wrote up the content in mostly-blog-post form first, and only created
the slides after that was complete. Overall, this worked very well for
me, and I'll try it again in the future. (If others want to share
their approaches to preparing talks, I'd definitely be happy to hear
them.)</p>
<p>As a result: I'm able to share the original write-up I did as
well. For those who saw the live talk (or the video): you may want to
skip towards the end, which covers some material that there wasn't
time for in the talk itself.</p>
<p>If you'd like to follow with
<a href="https://www.snoyman.com/reveal/what-makes-haskell-unique">the slides</a>,
they're also available.</p>
<hr />
<p>My name is Michael Snoyman. I work at a company called FP
Complete. One of the things we do is help individuals and companies
adopt Haskell, and functional programming in general. And that leads
right in to the topic of my talk today:</p>
<p><strong>What makes Haskell unique</strong></p>
<p>Programmers today have a large number of languages to choose from when
deciding what they will learn and use in their day to day coding.  In
order to make intelligent decisions about which languages to pursue,
people need to be able to quickly learn and understand what
distinguishes one language from another.</p>
<p>Given that this is a functional programming conference, it's probably
no surprise to you that Haskell can be called a functional programming
language. But there are lots of languages out there that can be called
functional. Definitions vary, but let's take a particularly lax
version of functional programming: first class functions, and higher
order functions. Well, by this defintion, even a language like C
counts! You may want to limit the definition further to include
syntactic support for closures, or some other features. Regardless,
the same point remains:</p>
<p><strong>Haskell may be functional, but that doesn't make it unique</strong></p>
<p>In fact, there's a long list of features I could rattle off that could
be used to describe Haskell.</p>
<ul>
<li>Functional</li>
<li>Statically typed</li>
<li>Pure</li>
<li>Lazy</li>
<li>Strongly typed</li>
<li>Green threads</li>
<li>Native executables</li>
<li>Garbage collected</li>
<li>Immutability</li>
</ul>
<p>Some of these features, like being pure and lazy, are relatively rare
in mainstream languages. Others, however, are common place. What I'm
going to claim is that not one of these features is enough to motivate
new people to Haskell—including people in this audience—to
start using it. Instead:</p>
<p><strong>It's the combination of these features that makes Haskell unique</strong></p>
<p>As an example: the intersection of purity, strong typing, and
functional programming style, for instance, lends itself to a high
level form of expression which is simultaneously easy to write, easy
to read, easy to modify, and efficient. I want to share some examples
of some code examples in Haskell that demonstrate how the language
encourages you to write code differently from other languages. And I'm
going to try to claim that this &quot;different&quot; style is awesome, though
it also has some downsides.</p>
<h2 id="async-i-o-and-concurrency">Async I/O and Concurrency</h2>
<p>Let's start off with a use case that's pretty popular today. Look at
this pseudocode and tell me what's wrong with it:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">json1 := httpGet(url1)
json2 := httpGet(url2)
useJsonBodies(json1, json2)
</span></code></pre>
<p>Given the heading of this slide, you may have guessed it: this is
blocking code. It will tie up an entire thread waiting for the
response body from each of these requests to come back. Instead, we
should be using asynchronous I/O calls to allow more efficient usage
of system resources. One common approach is to use callbacks:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">httpGetA(url1, |json1| =&gt;
  httpGetA(url2, |json2| =&gt;
    useJsonBodies(json1, json2)
  )
)
</span></code></pre>
<p>You may recognize this coding style as &quot;callback hell.&quot; There are
plenty of techniques in common languages to work around that, usually
around the idea of promises or futures. And you may have heard
something about how Javascript futures are a monad, and expect me to
be talking about how Haskell does monads better. But I'm not going to
do that at all. Instead, I want to show you what the asynchronous
version of the code looks like in Haskell</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">json1 </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> httpGet url1
json2 </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> httpGet url2
useJsonBodies json1 json2
</span></code></pre>
<p>This may surprise you, since this looks exactly like the blocking
pseudocode I showed above. It turns out that Haskell has a powerful
runtime system. It will automatically convert your blocking-style code
into asynchronous system calls, and automatically handle all of the
work of scheduling threads and waking them up when data is available.</p>
<p>This is pretty great, but it's hardly unique to Haskell. Erlang and
Go, as two popular examples, both have this as well. If we want to see
what makes Haskell different...</p>
<p>we have to go deeper.</p>
<h3 id="concurrency">Concurrency</h3>
<p>It's pretty lame that we need to wait for our first HTTP request to
complete before even starting our second. What we'd like to do is kick
off both requests at the same time. You may be imagining some really
hairy APIs with threads, and mutable variables, and locks. But here's
how you do this in Haskell:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">(json1, json2) </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> concurrently
  (httpGet url1)
  (httpGet url2)
useJsonBodies json1 json2
</span></code></pre>
<p>Haskell has a green thread implementation which makes forking threads
cheap. The <code>async</code> library provides a powerful, high level interface
performing actions in parallel without bothering with the low level
aspects of locking primitives and mutable variables. And this builds
naturally on top of the async I/O system already described to be cheap
about system resource usage.</p>
<h3 id="canceling">Canceling</h3>
<p>What we've seen already is elegant in Haskell, but it's not terribly
difficult to achieve in other languages. Let's take it to the next
level. Instead of needing both JSON response bodies, we only need one:
whichever one comes back first. In pseudocode, this might look like:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">promise1 := httpGet(url1)
promise2 := httpGet(url2)
result := newMutex()
promise1.andThen(|json1| =&gt;
  result.set(json1)
  promise2.cancel())
promise2.andThen(|json2| =&gt;
  result.set(json2)
  promise1.cancel())
useJsonBody(result.get())
</span></code></pre>
<p>This code is tedious and error prone, but it gets the job done. As you
can probably guess, there's a simple API for this in Haskell:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">eitherJson </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> race
  (httpGet url1)
  (httpGet url2)
</span><span style="color:#859900;">case</span><span style="color:#657b83;"> eitherJson </span><span style="color:#859900;">of
  </span><span style="color:#cb4b16;">Left</span><span style="color:#657b83;">  json1 </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> useJsonBody1 json1
  </span><span style="color:#cb4b16;">Right</span><span style="color:#657b83;"> json2 </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> useJsonBody2 json2
</span></code></pre>
<p>At first, this may seem like it's just a well designed API. But
there's quite a bit more going on under the surface. The Haskell
runtime system itself supports the idea of an asynchronous exception,
which allows us to cancel any other running thread. This feature is
vital to making <code>race</code> work.</p>
<p>And here's the final piece in the puzzle. All of the thread scheduing
and canceling logic I've described doesn't just apply to async I/O
calls. It works for CPU-intensive tasks as well. That means you can
fork thousands of threads, and even if one of them is busy performing
computation, other threads will not be starved. Plus, you can
interrupt these long-running computations:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let</span><span style="color:#657b83;"> tenSeconds </span><span style="color:#859900;">= </span><span style="color:#6c71c4;">10</span><span style="color:#657b83;"> * </span><span style="color:#6c71c4;">1000</span><span style="color:#657b83;"> * </span><span style="color:#6c71c4;">1000</span><span style="color:#657b83;">
timeout tenSeconds expensiveComputation
</span></code></pre><h3 id="summary-concurrency-and-async-i-o">Summary: concurrency and async I/O</h3>
<p><strong>Advantages</strong></p>
<ul>
<li>Cheap threads</li>
<li>Simple API</li>
<li>Highly responsive</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
<li>Complicated runtime system</li>
<li>Need to be aware of async exceptions when writing code</li>
</ul>
<h2 id="immutability-and-purity">Immutability and purity</h2>
<p>Most programming languages out there default to mutability: a variable
or field in a data structure can be changed at any time. Haskell is
different in two ways:</p>
<ol>
<li>Values are immutable by default, and mutability must be explicitly
indicated with a variable type</li>
<li>Mutating a mutable variable is considered a side effect, and that
mutable is tracked by the type system</li>
</ol>
<p>For example, the following Haskell-like code is impossible:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let</span><span style="color:#657b83;"> mut total </span><span style="color:#859900;">= </span><span style="color:#6c71c4;">0</span><span style="color:#657b83;">
    loop i </span><span style="color:#859900;">=
      if</span><span style="color:#657b83;"> i </span><span style="color:#859900;">&gt; </span><span style="color:#6c71c4;">1000000
        </span><span style="color:#859900;">then</span><span style="color:#657b83;"> total
        </span><span style="color:#859900;">else</span><span style="color:#657b83;"> total </span><span style="color:#859900;">+=</span><span style="color:#657b83;"> i; loop (i </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
 </span><span style="color:#859900;">in</span><span style="color:#657b83;"> loop </span><span style="color:#6c71c4;">1
</span></code></pre>
<p>From pure code, we cannot create, read, or modify a mutable
variable. We also need to say what kind of mutable variable we want:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">total </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> newIORef </span><span style="color:#6c71c4;">0
</span><span style="color:#859900;">let</span><span style="color:#657b83;"> loop i </span><span style="color:#859900;">=
      if</span><span style="color:#657b83;"> i </span><span style="color:#859900;">&gt; </span><span style="color:#6c71c4;">1000000
        </span><span style="color:#859900;">then</span><span style="color:#657b83;"> readIORef total
        </span><span style="color:#859900;">else do</span><span style="color:#657b83;">
          modifyIORef total (</span><span style="color:#859900;">+</span><span style="color:#657b83;"> i)
          loop (i </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
loop </span><span style="color:#6c71c4;">1
</span></code></pre>
<p>This is a lot of ceremony for a simple algorithm. Of course, the
recommended Haskell way of doing this would be to avoid mutable
variables, and use a more natural functional style.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let</span><span style="color:#657b83;"> loop i total </span><span style="color:#859900;">=
      if</span><span style="color:#657b83;"> i </span><span style="color:#859900;">&gt; </span><span style="color:#6c71c4;">1000000
        </span><span style="color:#859900;">then</span><span style="color:#657b83;"> total
        </span><span style="color:#859900;">else</span><span style="color:#657b83;"> loop (i </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) (total </span><span style="color:#859900;">+</span><span style="color:#657b83;"> i)
 </span><span style="color:#859900;">in</span><span style="color:#657b83;"> loop </span><span style="color:#6c71c4;">1 0
</span></code></pre>
<p>Besides pushing us towards this supposedly better functional approach,
why is immutable, pure code such a nice thing?</p>
<h3 id="reasoning-about-code">Reasoning about code</h3>
<p>You'll often hear Haskellers throw around a phrase &quot;reasoning about
code.&quot; Personally, I think the phrase is used to mean too many
different things. But let me give you an example that I think is
accurate. Let's look at some pseudocode:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">// scores.txt
Alice,32
Bob,55
Charlie,22

func main() {
  results := readResultsFromFile(&quot;results.txt&quot;)
  printScoreRange(results)
  print(&quot;First result was by: &quot; + results[0].name)
}

func printScoreRange(results: Vector&lt;TestResult&gt;) {
  ...
}
</span></code></pre>
<p>If you look at the code above, what do you expect the output to be? I
think it would be reasonable to guess something like:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">Lowest: 22
Highest: 55
First result was by: Alice
</span></code></pre>
<p>However, now let's throw in another piece of information: the
definition of <code>printScoreRange</code>:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">func printScoreRange(results: Vector&lt;TestResult&gt;) {
  results.sortBy(|result| =&gt; result.score)
  print(&quot;Lowest: &quot; + results[0].score)
  print(&quot;Highest: &quot; + results[results.len() - 1].score)
}
</span></code></pre>
<p>Suddenly our assumptions change. We can see that this function mutates
the <code>results</code> value passed to it. If we're passing mutable references
to vectors in this made up language, then our output is going to look
more like:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">Lowest: 22
Highest: 55
First result was by: Charlie
</span></code></pre>
<p>Since the original <code>results</code> value in our <code>main</code> function has been
modified. This is what I mean by hurting our ability to reason about
the code: it's no longer sufficient to look at just the <code>main</code>
function to understand what will be happening. Instead, we're required
to understand what may possibly be occurring in the rest of our
program to mutate our variables.</p>
<p>In Haskell, the code would instead look like:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#b58900;">main </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">IO </span><span style="color:#859900;">()
</span><span style="color:#657b83;">main </span><span style="color:#859900;">= do</span><span style="color:#657b83;">
  results </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> readResultsFromFile </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">results.txt</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">
  printScoreRange results
  putStrLn </span><span style="color:#859900;">$ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">First result was by: </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> name (head results)

</span><span style="color:#b58900;">printScoreRange </span><span style="color:#859900;">::</span><span style="color:#657b83;"> [</span><span style="color:#268bd2;">TestResult</span><span style="color:#657b83;">] </span><span style="color:#859900;">-&gt; </span><span style="color:#268bd2;">IO </span><span style="color:#859900;">()
</span><span style="color:#657b83;">printScoreRange results </span><span style="color:#859900;">= do
  let</span><span style="color:#657b83;"> results&#39; </span><span style="color:#859900;">=</span><span style="color:#657b83;"> sortBy score results
  putStrLn </span><span style="color:#859900;">$ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Lowest: </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> show (score (head results&#39;))
  putStrLn </span><span style="color:#859900;">$ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Highest: </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> show (score (last results&#39;))
</span></code></pre>
<p>We know that it's impossible for <code>printScoreRange</code> to modify the
<code>results</code> value we have in the <code>main</code> function. Looking at only this
bit of code in <code>main</code> is sufficient to know what will happen with the
<code>results</code> value.</p>
<h3 id="data-races">Data races</h3>
<p>Even more powerful than the single threaded case is how immutability
affects multithreaded applications. Ignoring the insanity of multiple
threads trying to output to the console at the same time, we can
easily parallelize our code:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#b58900;">main </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">IO </span><span style="color:#859900;">()
</span><span style="color:#657b83;">main </span><span style="color:#859900;">= do</span><span style="color:#657b83;">
  results </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> readResultsFromFile </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">results.txt</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;">
  concurrently_ printFirstResult printScoreRange

printFirstResult results </span><span style="color:#859900;">=</span><span style="color:#657b83;">
  putStrLn </span><span style="color:#859900;">$ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">First result was by: </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> name (head results)

printScoreRange results </span><span style="color:#859900;">= do
  let</span><span style="color:#657b83;"> results&#39; </span><span style="color:#859900;">=</span><span style="color:#657b83;"> sortBy score results
  putStrLn </span><span style="color:#859900;">$ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Lowest: </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> show (score (head results&#39;))
  putStrLn </span><span style="color:#859900;">$ </span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">Highest: </span><span style="color:#839496;">&quot; </span><span style="color:#859900;">++</span><span style="color:#657b83;"> show (score (last results&#39;))
</span></code></pre>
<p>There's no need to worry about concurrent accesses to data
structures. It's impossible for the other threads to alter our
data. If you do want other threads to affect your local data, you'll
need to be more explicit about it, which we'll get back to.</p>
<h3 id="mutability-when-needed">Mutability when needed</h3>
<p>One thing you may be worried about is how this affects
performance. For example, it's much more efficient to sort a vector
using mutable access instead of only pure operations. Haskell has two
tricks for that. The first is the ability to explicitly create mutable
data structures, and mutate them in place. This breaks all of the
guarantees I already mentioned, but if you need the performance, it's
available. And unlike mutable-by-default approaches, you now know
exactly which pieces of data you need to handle with care when coding
to avoid tripping yourself up.</p>
<p>The other approach is to create a mutable copy of the original data,
perform your mutable algorithm on it, and then freeze the new copy
into an immutable version. With sorting, this looks something like:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#b58900;">sortMutable </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">MutableVector a </span><span style="color:#859900;">-&gt; </span><span style="color:#268bd2;">ST</span><span style="color:#657b83;"> (</span><span style="color:#268bd2;">MutableVector a</span><span style="color:#657b83;">)
sortMutable </span><span style="color:#859900;">= ... </span><span style="color:#93a1a1;">-- normal sorting algorithm

</span><span style="color:#b58900;">sortImmutable </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">Vector a </span><span style="color:#859900;">-&gt; </span><span style="color:#268bd2;">Vector a
</span><span style="color:#657b83;">sortImmutable orig </span><span style="color:#859900;">=</span><span style="color:#657b83;"> runST </span><span style="color:#859900;">$ do</span><span style="color:#657b83;">
  mutable </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> newMutableVector (length orig)
  copyValues orig mutable
  sort mutable
  freeze mutable
</span></code></pre>
<p><code>ST</code> is something we use to have temporary and local mutable
effects. Because of how it's implemented, we know that none of the
effects can be visible from outside of our function, and that for the
same input, the <code>sortImmutable</code> function will always have the same
output. While this approach requires an extra memory buffer and an
extra copy of the elements in the vector, it avoids completely the
worries of your data being changed behind your back.</p>
<h3 id="summary-immutability-and-purity">Summary: immutability and purity</h3>
<p><strong>Advantages</strong></p>
<ul>
<li>Easier to reason about code</li>
<li>Avoid many cases of data races</li>
<li>Functions are more reliable, returning the same output for the same
input</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
<li>Lots of ceremony if you actually want mutation</li>
<li>Some runtime performance hit for mutable algorithms</li>
</ul>
<h2 id="software-transactional-memory">Software Transactional Memory</h2>
<p>Let's say you actually need to be able to mutate some values. And for
fun, let's say you want to do this from multiple threads. A common
example of this is a bank. Let's again play with some pseudocode:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">runServer (|request| =&gt; {
  from := accounts.lookup(request.from)
  to := accounts.lookup(request.to)
  accounts.set(request.from, from - request.amt)
  accounts.set(request.to, to + request.amt)
})
</span></code></pre>
<p>This looks reasonable, except that if two requests come in at the same
time for the same account, we can end up with a race
condition. Consider something like this:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">Thread 1: receive request: Alice gives $25
Thread 2: receive request: Alice receives $25
Thread 1: lookup that Alice has $50
Thread 2: lookup that Alice has $50
Thread 1: set Alice&#39;s account to $25
Thread 2: set Alice&#39;s account to $75
</span></code></pre>
<p>We know that we want Alice to end up with $50, but because of our data
race, Alice ends up with $75. Or, if the threads ran differently, it
could be $25. Neither of these is correct. In order to avoid this, we
would typically deal with some kind of locking:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">runServer (|request| =&gt; {
  accounts.lock(request.from)
  accounts.lock(request.to)
  // same code as before
  accounts.unlock(request.from)
  accounts.unlock(request.to)
})
</span></code></pre>
<p>Unfortunately, this leads to deadlocks! Consider this scenario:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">Thread 1: receive request: $50 from Alice to Bob
Thread 2: receive request: $50 from Bob to Alice
Thread 1: lock Alice
Thread 2: lock Bob
Thread 1: try to lock Bob, but can&#39;t, so wait
Thread 2: try to lock Alice, but can&#39;t, so wait
...
</span></code></pre>
<p>This kind of problem is the bane of many concurrent programs. Let me
show you another approach. As you may guess, here's some Haskell:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">runServer </span><span style="color:#859900;">$ \</span><span style="color:#657b83;">request </span><span style="color:#859900;">-&gt;</span><span style="color:#657b83;"> atomically </span><span style="color:#859900;">$ do
  let</span><span style="color:#657b83;"> fromVar </span><span style="color:#859900;">=</span><span style="color:#657b83;"> lookup (from request) accounts
      toVar </span><span style="color:#859900;">=</span><span style="color:#657b83;"> lookup (to request) accounts
  origFrom </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> readTVar fromVar
  writeTVar fromVar (origFrom </span><span style="color:#859900;">-</span><span style="color:#657b83;"> amt request)
  origTo </span><span style="color:#859900;">&lt;-</span><span style="color:#657b83;"> readTVar toVar
  writeTVar toVar (origTo </span><span style="color:#859900;">+</span><span style="color:#657b83;"> amt request)
</span></code></pre>
<p>There are helper functions to make this shorter, but I wanted to do
this the long way to prove a point. This looks like <em>exactly</em> the kind
of race condition I described before. However, that <code>atomically</code>
function is vital here. It ensures that only a complete transaction is
ever committed. If any of the variables we touch are mutated by
another thread before our transaction is complete, all of our changes
are rolled back, and the transaction is retried. No need for explicit
locking, and therefore many less worries about data races and
deadlocks.</p>
<p>A <code>TVar</code> is a &quot;transactional variable.&quot; It's an alternative to the
<code>IORef</code> that I mentioned earlier. There are other kinds of mutable
variables in Haskell, including channels and <code>MVar</code>s which are like
mutexes. This is what I meant when I said you need to be explicit
about what kind of mutation you want in Haskell.</p>
<h3 id="purity-s-role">Purity's role</h3>
<p>What do you think will happen with this program:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">atomically </span><span style="color:#859900;">$ do</span><span style="color:#657b83;">
  buyBitcoins </span><span style="color:#6c71c4;">3 </span><span style="color:#93a1a1;">-- side effects on my bank account
</span><span style="color:#657b83;">
  modifyTVar myBitcoinCount (</span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">)
</span></code></pre>
<p>Here, <code>buyBitcoins</code> is going off to some exchange a buying about
$100,000 in bitcoin (or whatever ridiculous amount they're selling for
now). I said before that, if the variables are modified while running,
the transaction will be retried. It seems like this function is very
dangerous, as it may result in me going about $10,000,000 into debt
buying bitcoins!</p>
<p>This is where purity steps in. Inside <code>atomically</code>, you are not
allowed to perform any side effects outside of STM itself. That means
you can modify <code>TVar</code>s, but you cannot read or write files, print to the
console, fire the missiles, or place multi million dollar currency
purchases. This may feel like a limitation, but the tradeoff is that
it's perfectly safe for the runtime system to retry your transactions
as many times as it wants.</p>
<h3 id="summary-of-stm">Summary of STM</h3>
<p><strong>Advantages</strong></p>
<ul>
<li>Makes concurrent data modification much easier</li>
<li>Bypass many race conditions and deadlocks</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
<li>Depends on purity to work at all</li>
<li>Not really a disadvantage, you're already stuck with purity in
Haskell</li>
<li>Not really any other disadvantages, so just use it!</li>
</ul>
<h2 id="laziness">Laziness</h2>
<p>It's a little cheeky of me to get this far into a talk about unique
features of Haskell and ignore one of its most notable features:
laziness. Laziness is much more of a double-edged sword than the other
features I've talked about, and let me prove that by revisiting one of
our previous examples.</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let</span><span style="color:#657b83;"> loop i total </span><span style="color:#859900;">=
      if</span><span style="color:#657b83;"> i </span><span style="color:#859900;">&gt; </span><span style="color:#6c71c4;">1000000
        </span><span style="color:#859900;">then</span><span style="color:#657b83;"> total
        </span><span style="color:#859900;">else</span><span style="color:#657b83;"> loop (i </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) (total </span><span style="color:#859900;">+</span><span style="color:#657b83;"> i)
 </span><span style="color:#859900;">in</span><span style="color:#657b83;"> loop </span><span style="color:#6c71c4;">1 0
</span></code></pre>
<p>I didn't describe it before, but this function will sum up the numbers
from 1 to 1,000,000. There are two problems with this function:</p>
<ol>
<li>There's a major performance bug in it</li>
<li>It's much more cumbersome than it should be</li>
</ol>
<h3 id="space-leaks">Space leaks</h3>
<p>The bane of laziness is space leaks, something you've probably heard
about if you've read at all about Haskell. To understand this, let's
look at how laziness is implemented. When you say something like:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let</span><span style="color:#657b83;"> foo </span><span style="color:#859900;">= </span><span style="color:#6c71c4;">1 </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">2
</span></code></pre>
<p><code>foo</code> doesn't actually contain <code>3</code> right now. Instead, it contains an
instruction to apply the operator <code>+</code> to the values <code>1</code> and <code>2</code>. This
kind of instruction is called a <em>thunk</em>. And as you might guess,
storing the thunk is a lot more expensive than storing a simple
integer. We'll see why this helps in a bit, but for now we just care
about why it sucks. Let's look at what happens in our <code>loop</code> function:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let</span><span style="color:#657b83;"> loop i total </span><span style="color:#859900;">=
      if</span><span style="color:#657b83;"> i </span><span style="color:#859900;">&gt; </span><span style="color:#6c71c4;">1000000
        </span><span style="color:#859900;">then</span><span style="color:#657b83;"> total
        </span><span style="color:#859900;">else</span><span style="color:#657b83;"> loop (i </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) (total </span><span style="color:#859900;">+</span><span style="color:#657b83;"> i)
 </span><span style="color:#859900;">in</span><span style="color:#657b83;"> loop </span><span style="color:#6c71c4;">1 0
</span></code></pre>
<p>Each time we step through the loop, we have to compare <code>i</code> to the
number 1,000,000. Therefore, we are forced to evaluate it, which means
turning it into a simple integer. But we never look at the value of
<code>total</code>. Instead of storing a simple integer, which would be cheap, we
end up building a huge tree that looks like &quot;add 1 to the result of
add 2 to the result of ... to 1,000,000.&quot; This is really bad: it uses
more memory and more CPU than we'd like.</p>
<p>We can work around this in Haskell by being explicit about which
values should be evaluated. There are a few ways to do this, but in
our case, the easiest is:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">let</span><span style="color:#657b83;"> loop i </span><span style="color:#859900;">!</span><span style="color:#657b83;">total </span><span style="color:#859900;">=
      if</span><span style="color:#657b83;"> i </span><span style="color:#859900;">&gt; </span><span style="color:#6c71c4;">1000000
        </span><span style="color:#859900;">then</span><span style="color:#657b83;"> total
        </span><span style="color:#859900;">else</span><span style="color:#657b83;"> loop (i </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) (total </span><span style="color:#859900;">+</span><span style="color:#657b83;"> i)
 </span><span style="color:#859900;">in</span><span style="color:#657b83;"> loop </span><span style="color:#6c71c4;">1 0
</span></code></pre>
<p>All I've done is added an exclamation point in front of the <code>total</code>
argument. This is known as a bang pattern, and says &quot;make sure this is
evaluated before running the rest of this function.&quot; The need to do
this in some cases is definitely a downside to Haskell's laziness. On
the other hand, as we'll see shortly, you often don't need to bother
if you use the right kinds of functions.</p>
<h3 id="laziness-is-awesome">Laziness is awesome</h3>
<p>Let's go back to pseudocode and rewrite our summation:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">total := 0
for(i := 1; i &lt;= 1000000; i++) {
  total += i
}
</span></code></pre>
<p>Pretty simple. But now let's modify this to only sum up the even
numbers:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">total := 0
for(i := 1; i &lt;= 1000000; i++) {
  if (isEven(i)) {
    total += i
  }
}
</span></code></pre>
<p>OK, that's fine. But now, let's sum up the indices modulus 13 (for
some weird reason):</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">total := 0
for(i := 1; i &lt;= 1000000; i++) {
  if (isEven(i)) {
    total += i % 13
  }
}
</span></code></pre>
<p>Each of these modifications is fine on its own, but at this point it's
getting harder to see the forest for the trees. And fortunately each
of these transformations was relatively simple. If some of the
requirements were more complicated, fitting it into the <code>for</code> loop may
be more challenging.</p>
<p>Let's go back to the beginning with Haskell. We saw how we could do it
with a loop, but let's see the real way to sum the numbers from 1 to
1,000,000:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#93a1a1;">-- Bad
</span><span style="color:#859900;">let</span><span style="color:#657b83;"> loop i </span><span style="color:#859900;">!</span><span style="color:#657b83;">total </span><span style="color:#859900;">=
      if</span><span style="color:#657b83;"> i </span><span style="color:#859900;">&gt; </span><span style="color:#6c71c4;">1000000
        </span><span style="color:#859900;">then</span><span style="color:#657b83;"> total
        </span><span style="color:#859900;">else</span><span style="color:#657b83;"> loop (i </span><span style="color:#859900;">+ </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">) (total </span><span style="color:#859900;">+</span><span style="color:#657b83;"> i)
 </span><span style="color:#859900;">in</span><span style="color:#657b83;"> loop </span><span style="color:#6c71c4;">1 0

</span><span style="color:#93a1a1;">-- Awesome!
</span><span style="color:#657b83;">sum [</span><span style="color:#6c71c4;">1</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">1000000</span><span style="color:#657b83;">]
</span></code></pre>
<p>We use list range syntax to create a list with one million numbers in
it. On its face, this looks terrible: we need to allocate about 8mb of
data to hold onto these integers, when this should run in constant
space. But this is exactly where laziness kicks in: instead of
allocating all of these values immediately, we allocate a thunk. Each
time we step through the list, our thunk generates one new integer and
a new thunk for the rest of the list. We're never using more than a
few machine words.</p>
<p>There are also other optimizations in GHC to avoid even allocating
those thunks, but that's not something I'm going to cover today.</p>
<p>Anyway, let's continue. We can easily tweak this to only add up the
even numbers:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">sum (filter even [</span><span style="color:#6c71c4;">1</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">1000000</span><span style="color:#657b83;">])
</span></code></pre>
<p>This uses the <code>filter</code> higher order function, and likewise avoids
allocating an entire list at once. And doing the silly modulus 13
trick:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">sum (map (</span><span style="color:#859900;">`mod` </span><span style="color:#6c71c4;">13</span><span style="color:#657b83;">) (filter even [</span><span style="color:#6c71c4;">1</span><span style="color:#859900;">..</span><span style="color:#6c71c4;">1000000</span><span style="color:#657b83;">]))
</span></code></pre>
<p>Laziness is definitely a mixed bag, but combined with the functional
style of Haskell in general, it allows you to write higher level,
declarative code, while keeping great performance.</p>
<h3 id="short-circuiting-for-free">Short circuiting for free</h3>
<p>Lots of languages define <code>&amp;&amp;</code> and <code>||</code> operators which stop evaluation
early, e.g.:</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">foo() &amp;&amp; bar()
</span></code></pre>
<p><code>bar</code> is only called if <code>foo</code> returns <code>true</code>. Haskell works the same way, but these operators aren't special; they just use laziness!</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#cb4b16;">False</span><span style="color:#657b83;"> &amp;&amp; _ </span><span style="color:#859900;">= </span><span style="color:#cb4b16;">False
True</span><span style="color:#657b83;"> &amp;&amp; x </span><span style="color:#859900;">=</span><span style="color:#657b83;"> x

</span><span style="color:#cb4b16;">True </span><span style="color:#859900;">||</span><span style="color:#657b83;"> _ </span><span style="color:#859900;">= </span><span style="color:#cb4b16;">True
False </span><span style="color:#859900;">||</span><span style="color:#657b83;"> x </span><span style="color:#859900;">=</span><span style="color:#657b83;"> x
</span></code></pre>
<p>This even scales up to functions working on lists of values, such as
<code>and</code>, <code>or</code>, <code>all</code>, and <code>any</code>.</p>
<h3 id="other-downsides">Other downsides</h3>
<p>There's one other downside to laziness, and a historical
artifact. Laziness means that exceptions can be hiding inside any
thunk. This is also known as partial values and partial functions. For
example, what does this mean?</p>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#657b83;">head </span><span style="color:#b58900;">[]
</span></code></pre>
<p>Generally speaking, partiality is frowned upon, and you should use
total functions in Haskell.</p>
<p>The historical artifact is that many bad functions are still easily
available, and they should be avoided. <code>head</code> is arguably an example
of that. Another is the lazy left fold function, <code>foldl</code>. In virtually
all cases, you should replace it with a strict left fold <code>foldl'</code>.</p>
<h3 id="summary-of-laziness">Summary of laziness</h3>
<p><strong>Advantages</strong></p>
<ul>
<li>More composable code</li>
<li>Get efficient results from combining high level functions</li>
<li>Short-circuiting like <code>&amp;&amp;</code> and <code>||</code> is no longer a special case</li>
</ul>
<p><strong>Disadvantages</strong></p>
<ul>
<li>Need to worry about space leaks</li>
<li>Exceptions can be hiding in many places</li>
<li>Unfortunately some bad functions like <code>foldl</code> still hanging around</li>
</ul>
<p><strong>Side note</strong> There's a major overlap with Python generators or Rust
iterators, but laziness in Haskell is far more pervasive than these
other approaches.</p>
<h2 id="others">Others</h2>
<p>Due to time constraints, I'm not going to be able to go into detail on
a bunch of other examples I wanted to talk about. Let me just throw
out some quick thoughts on them.</p>
<h3 id="parser-and-other-dsls">Parser (and other) DSLs</h3>
<ul>
<li>Operator overloading!</li>
<li>Abstract type classes like <code>Applicative</code> and <code>Alternative</code> a natural
fit, e.g.: <code>parseXMLElement &lt;|&gt; parseXMLText</code>.</li>
<li>Able to reuse huge number of existing library functions,
e.g. <code>optional</code>, <code>many</code></li>
<li>General purpose <code>do</code>-notation is great</li>
</ul>
<pre style="background-color:#fdf6e3;">
<code><span style="color:#859900;">data </span><span style="color:#cb4b16;">Time </span><span style="color:#859900;">= </span><span style="color:#cb4b16;">Time Hour Minutes Seconds</span><span style="color:#657b83;"> (</span><span style="color:#cb4b16;">Maybe AmPm</span><span style="color:#657b83;">)
</span><span style="color:#859900;">data </span><span style="color:#cb4b16;">AmPm </span><span style="color:#859900;">= </span><span style="color:#cb4b16;">Am </span><span style="color:#859900;">| </span><span style="color:#cb4b16;">Pm

</span><span style="color:#b58900;">parseAmPm </span><span style="color:#859900;">:: </span><span style="color:#268bd2;">Parser Time
</span><span style="color:#657b83;">parseAmPm </span><span style="color:#859900;">= </span><span style="color:#cb4b16;">Time
  </span><span style="color:#859900;">&lt;$&gt;</span><span style="color:#657b83;"> decimal
  </span><span style="color:#859900;">&lt;</span><span style="color:#657b83;">*</span><span style="color:#859900;">&gt;</span><span style="color:#657b83;"> (</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">:</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;"> *</span><span style="color:#859900;">&gt;</span><span style="color:#657b83;"> decimal)
  </span><span style="color:#859900;">&lt;</span><span style="color:#657b83;">*</span><span style="color:#859900;">&gt;</span><span style="color:#657b83;"> (</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">:</span><span style="color:#839496;">&quot;</span><span style="color:#657b83;"> *</span><span style="color:#859900;">&gt;</span><span style="color:#657b83;"> decimal)
  </span><span style="color:#859900;">&lt;</span><span style="color:#657b83;">*</span><span style="color:#859900;">&gt;</span><span style="color:#657b83;"> optional ((</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">AM</span><span style="color:#839496;">&quot; </span><span style="color:#859900;">$&gt; </span><span style="color:#cb4b16;">Am</span><span style="color:#657b83;">) </span><span style="color:#859900;">&lt;|&gt;</span><span style="color:#657b83;"> (</span><span style="color:#839496;">&quot;</span><span style="color:#2aa198;">PM</span><span style="color:#839496;">&quot; </span><span style="color:#859900;">$&gt; </span><span style="color:#cb4b16;">Pm</span><span style="color:#657b83;">))
</span></code></pre>
<p>c/o <a href="https://twitter.com/queertypes/status/941064338848100352">@queertypes</a></p>
<h3 id="advanced-techniques">Advanced techniques</h3>
<ul>
<li>Free monads</li>
<li>Monad transformer stacks</li>
<li>Lens, conduit, pipes, ...</li>
<li>Lots of ways to do things in Haskell!</li>
<li>It's a plus and a minus</li>
<li>Recommendation: choose a useful subset of Haskell and its libraries,
and define some best practices</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<ul>
<li>Haskell combines a lot of uncommon features</li>
<li>Very few of those features are unique</li>
<li>Combining those features allows you to write code very differently
than in other languages</li>
<li>If you want readable, robust, easy to maintain code: I think it's a
great choice</li>
<li>Be aware of the sharp edges: they do exist!</li>
</ul>
<h2 id="q-a">Q&amp;A</h2>


<div class="text-center"><a href="/blog/" class="btn btn-primary">Read more blog posts</a></div>

      <div id="disqus_thread"></div>
      <script>
        (function() {var d = document, s = d.createElement('script'); s.src = '//snoyberg.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s);})();
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<!--
    </div>

    <div class="col-lg-3" id="archive">
      <h3>Blog archive</h3>
      <ul class="blog-archive">
            $forall ((year, month, slug), post) <- posts
                <li>
                    <a href=@?{addPreview $ PostR year month slug}>#{postTitle post}
                    \ #
                    <i>#{prettyDay now (postTime post)}
-->

<div class="text-center"><a href="/blog/" class="btn btn-primary">Read more blog posts</a></div>


            </div>
          </div>
        </div>
      </section>
    </main>

    
<footer class="bg-dark py-5">
  <ul class="list-inline text-center text-md-right mb-0">
    <li class="list-inline-item mx-2">
      <a href="https://twitter.com/snoyberg">Follow @snoyberg</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://twitter.com/intent/tweet?screen_name=snoyberg">Tweet to @snoyberg</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://github.com/snoyberg">Github</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://tech.fpcomplete.com/">FP Complete</a>
    </li>
    <li class="list-inline-item mx-2">
      <a href="https://www.haskellers.com/user/snoyberg">I'm a Haskeller</a>
    </li>
  </ul>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1434510-21', 'auto');
  ga('send', 'pageview');
</script>

<!-- JS Script Files -->
<!-- Global Vendor -->
<script src="/maxi/vendors/jquery.min.js"></script>
<script src="/maxi/vendors/jquery.migrate.min.js"></script>
<script src="/maxi/vendors/popper.min.js"></script>
<script src="/maxi/vendors/bootstrap/js/bootstrap.min.js"></script>

<!-- Components Vendor  --> 
<script src="/maxi/contact/jqBootstrapValidation.js"></script>
<!--Plugin Initialize-->
<script src="/maxi/js/global.js"></script>
<!-- END JAVASCRIPTS -->


  </body>
</html>
